\documentclass[submission,copyright,creativecommons]{eptcs}
% \providecommand{\event}{EXPRESS'10} % Name of the event you are submitting to
% \usepackage{breakurl}             % Not needed if you use pdflatex only.


% \documentclass{llncs}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{color}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{amsmath}
%\usepackage{harvard}
%\bibliographystyle{alpha}
%\textheight = 20.8cm
%\textwidth = 12.5cm


\newcommand{\post}[1]{\mbox{$#1^{\bullet}$}}
\newcommand{\pre}[1]{\mbox{$^{\bullet}#1$}}
\newcommand{\postr}[1]{#1^{\circ}}
\newcommand{\prer}[1]{\mbox{$^{\circ}#1$}}

%\newcommand{\deriv}[1]{{\mbox{${\:\stackrel{#1}{\rightarrow}\:}$}}}
% \def\bbbn{{\rm I\!N}}
\newcommand{\nat}{{\rm I\!N}}
\newcommand{\hide}{/}
%\newcommand{\restr}{\backslash}
%\newcommand{\fine}{\hfill{$\rule{2mm}{2mm}$}}
%\newcommand{\proof}{\noindent{\em Proof.}\ \  }

\newcommand{\lv}[1]{\Lambda_{#1}}
\newcommand{\hv}[1]{\mathcal{ H}_{#1}}
\newcommand{\lvtrace}{\stackrel{\Lambda}{\approx}_{tr}}
\newcommand{\lvbis}{\stackrel{\Lambda}{\approx}_{bis}}

\newcommand{\redStr}[1]{\color{red}#1\color{black}\ }
\newcommand{\angbr}[1]{\langle #1 \rangle}
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\bullet$}
\renewcommand{\labelitemiii}{$\bullet$}

\newtheorem{adefinizione}{Definition}[section]
\newtheorem{afact}[adefinizione]{Fact}
\newtheorem{alemma}[adefinizione]{Lemma}
\newtheorem{teorema}[adefinizione]{Theorem}
\newtheorem{corollario}[adefinizione]{Corollary}
\newtheorem{proposizione}[adefinizione]{Proposition}
\newtheorem{esempio}[adefinizione]{Example}

%\newcommand{\proof}{{\it Proof: }}
\newcommand{\linib}{\mbox{$\sqsubset$}}
\newcommand{\ginib}{\mbox{$\sqsupset$}}
\newcommand{\leqinib}{\mbox{$\sqsubseteq$}}
\newcommand{\geqinib}{\mbox{$\sqsupseteq$}}
\newcommand{\emlim}{EL}
\newcommand{\fine}{{\mbox{ }\nolinebreak\hfill{$\Box$}}}
%\newcommand{\post}[1]{#1^{\bullet}}
%\newcommand{\pre}[1]{{^{\bullet}#1}}
\newcommand{\inib}[1]{{^{\circ}#1}}
\newcommand{\test}[1]{\widehat{#1}}
\newcommand{\init}{*}

\newcommand{\postn}[2]{#1^{\bullet_{#2}}}
\newcommand{\pren}[2]{{^{\bullet_{#2}}#1}}
%\newcommand{\testn}[2]{\whidehat_{#2}{#1}}

% macro causal semantics
\newcommand{\Max}[1]{Max(#1)}
\newcommand{\Min}[1]{Min(#1)}
\newcommand{\ctop}{\mbox{${\cal F}$}}
\newcommand{\ptoc}{\mbox{${\cal G}$}}

% macro sem picalcolo
\newcommand{\dec}{\mbox{$dec$}}
\newcommand{\sost}[2]{\mbox{$\{#1/#2\}$}}
\newcommand{\deriv}[1]{{\mbox{${\:\stackrel{#1}{\longrightarrow}\:}$}}}
\newcommand{\derivas}[1]{{\mbox{${\:\stackrel{#1}{\longrightarrow_s}\:}$}}}
\newcommand{\nderiv}[1]{{\mbox{${\;\;\;\not\!\!\!\stackrel{#1}{\longrightarrow}\;}$}
}}
\newcommand{\cderiv}[1]{{\mbox{${\:\stackrel{#1}{-\!-\!\!\!\longrightarrow}\:}$}}}
\newcommand{\eqdef}{{\mbox{${\stackrel{def}{=}}$}}}
\newcommand{\spazio}{\hspace{2.4em}}
\newcommand{\bigfrac}[2]{
\renewcommand{\arraystretch}{1.5}
\begin{array}{c}#1\\
\hline
#2
\end{array}}
\newcommand{\restr}[1]{\mbox{$({\bf\nu} #1)$}}
\newcommand{\para}{\mbox{$\,|\,$}}
\newcommand{\recx}[1]{\mbox{rec$\, X.#1$}}
\newcommand{\rec}[2]{\mbox{rec}\, #1.#2}
\newcommand{\parti}{\mbox{\raisebox{.4ex}{$\wp$}}}
%\newcommand{\minus}{\stackrel
%{\raisebox{-.1cm}[.1cm][.1cm]{.}}{\raisebox{-.01cm}[.1cm][.1cm]{-}}}
\newcommand{\minus}{\stackrel{\cdot}{-}}
\newcommand{\myequiv}{\stackrel{\rm def}{=}}
\newcommand{\nil}{\mbox{\bf 0}}
\newcommand{\alphaconv}{\equiv_{\alpha}}

\newcommand{\istar}{\mbox{$*\,$}}
\newcommand{\parastar}{\mbox{$\,\stackrel{*}{|}\,$}}
\newcommand{\tderiv}[1]{{\mbox{${\:\stackrel{#1}{\longmapsto}\:}$}}}
\newcommand{\undef}{\mbox{$\bot$}}
    
\newcommand{\encoding}[2]{\ensuremath{\llbracket #2 \rrbracket^{#1}}}
\newcommand{\vect}[1]{\ensuremath{\tilde{#1}}}

\newtheorem{adefinition}{Definition}
\newtheorem{atheorem}[adefinition]{Theorem}
\newtheorem{aproposition}[adefinition]{Proposition}
\newtheorem{acorollary}[adefinition]{Corollary}
% \newtheorem{afact}[adefinition]{Fact}
% \newtheorem{alemma}[adefinition]{Lemma}
\newtheorem{aexample}{\it Example}
\newenvironment{definition}{\begin{adefinition}}{\end{adefinition}}
\newenvironment{theorem}{\begin{atheorem} }{\end{atheorem}}
\newenvironment{proposition}{\begin{aproposition}}{\end{aproposition}}
\newenvironment{corollary}{\begin{acorollary} }{\end{acorollary}}
% \newenvironment{lemma}{\begin{alemma} }{\end{alemma}}
\newenvironment{example}{\begin{aexample} }{\end{aexample}}
\newcommand{\proof}{{\it Proof:}\ \ }
% 
% \newtheorem{aexample}{\it Example}
% 
% \newenvironment{example}{\begin{aexample} }{\end{aexample}}



\title{Multi-$\pi$: a calculus for mobile multi-party\\
and transactional communication}
\author{Roberto Gorrieri and Cristian Versari
\institute{Dipartimento di Scienze dell'Informazione, Universit\`a di
Bologna, \\Mura A. Zamboni, 7,
40127 Bologna, Italy}
\email{\{gorrieri, versari\}@cs.unibo.it}
}
\def\titlerunning{Multi-$\pi$ for mobile multi-party communication}
\def\authorrunning{R. Gorrieri \& C. Versari}


\begin{document}
\maketitle

\begin{abstract}
Multi-$\pi$ is a conservative extension of $\pi$-calculus, enriched with an additional 
operator of strong prefixing, enabling the modeling of atomic sequences of actions.
Multiparty synchronization can be
implemented as an atomic sequence of binary synchronizations, where the leader of the synchronization
is performing a (long) atomic sequence and all the other partners are performing one single complementary action.
Transactional communication is the synchronization of two (or more) processes, each performing a (long)
atomic sequence.
Some classic problems are presented to show the rich expressiveness of the calculus.
We also show that polyadic communication \cite{Mil91} and polyadic synchronization \cite{CM03}
can be implemented in Multi-$\pi$ thanks to its transactional synchronization.
We provide two operational semantics for this calculus
at two different levels of abstraction and prove that the two coincide.
\end{abstract}


\section{Introduction\\[-.8cm]}
The %process algebra 
$\pi$-calculus  \cite{MPW}, largely used in academia as a foundational language to study concurrent systems, 
is not expressive enough to model some useful behaviors in real-world systems. For instance, there is no means to 
express that certain sequences of actions are to be executed atomically, i.e., their execution is {\em all-or-nothing}; 
similarly, it is not possible to express multi-party synchronization where more than two processes communicate, nor
a transactional synchronization where two (or more) partners perform a long synchronization on a sequence of
actions.

In this paper, we present a conservative extension of $\pi$-calculus, called Multi-$\pi$,  
to model atomic actions as well as multiway  and transactional synchronizations. 
This extension is based on the addition of the  operator of {\em strong prefixing} 
(in opposition to normal prefixing),  denoted $\underline{\mu}.P$, that is used to create atomic sequences.
This operator was originally presented in \cite{GMM,GM90} as an addition to CCS. 
Classical problems where multiway synchronization (or transactional sycnhronization) is required (implemented 
as an atomic sequence of binary synchronizations) can be now modeled faithfully. 
As typical examples of this class of problems, we will consider Patil's cigarette smokers' problem \cite{Pat71},  
for which no deadlock-free and livelock-free solution exists in $\pi$-calculus. 
%This problem can be modelled
%in Multi-$\pi$ by imposing that the acquisition of the two ingredients needed to a smoker to make a cigarette
%is an atomic action.
Moreover, we present a variation of Dijkstra's dining philosophers problem \cite{Dij68}, where each philosopher 
is the owner of one fork and asks for the second fork to his neighbor. Finally, we elaborate on Milner's
example of mobile phones \cite{Mil91}, where the cell serving the phone can change
during the conversation. These examples show the interplay between mobility and atomic sequences of 
binary communications.

Multi-$\pi$ is a very expressive calculus. Besides the examples cited above, we show that
$(i)$ the choice operator is derivable easily from the others, 
$(ii)$ polyadic $\pi$-calculus \cite{Mil91,Mil99} 
is a subcalculus of Multi-$\pi$, and that $(iii)$ polyadic synchronization \cite{CM03} is a derived operator in Multi-$\pi$.
Finally $(iv)$ we present a problem, the so-called {\em last man standing} problem \cite{VBG09} that cannot 
be solved in Multi-$\pi$.

Multi-$\pi$ is equipped with two operational semantics in terms of labeled transition systems: 
an abstract semantics where each transition is a transaction (labeled by a sequence) 
and a low-level one where each transition is labeled by one single action, but not all the states are observable; 
unobservable states represent the fact that the process is in the middle of an atomic action and so its partial
behavior cannot be observed.
We prove that the two semantics coincide on observable states, even if the low-level semantics can deadlock 
more often than the high-level semantics. For instance, the process $\underline\mu.\nil + \alpha.\nil$ 
can perform only
one transition $\alpha$ in the abstract labeled transition system, while it can also perform a low-level transition
labeled with $\mu$, reaching, however, an unobservable state.

The paper is organized as follows. Section \ref{multi-syntax} presents the syntax of the calculus,
recalling mainly the basic notation of $\pi$-calculus. 
In Section \ref{multi-hi} we provide the high-level semantics of the calculus,
together with some basic properties. 
Section \ref{multi-ex} is devoted to the presentation of the case studies. 
Section \ref{multi-expr} studies some expressiveness result for the calculus.
Section \ref{multi-low} presents
the low-level semantics for Multi-$\pi$ and the proof that the two semantics coincide over observable states.
Section \ref{multi-conc} concludes the paper with a comparison with related literature and some hints for future research.

\section{The Multi-$\pi$ calculus: Syntax} \label{multi-syntax}

Let ${\mathcal N}$ be a countable set of names, ranged over by 
$a,b,\ldots,x,y,\ldots$, and $\tau\not\in{\mathcal N}$.
%Let ${\mathcal C}$ be a countable set of process constants, disjoint from 
%${\mathcal N}\cup\{\tau\}$, ranged over by $A, B, C,\ldots$.
Terms are generated from names by the following grammar:

\[p ::= \nil \; \mid \; \mu.q \; \mid \;   \underline{\mu}.q \; \mid \;  p+p  \; \; \; \mbox{  {\em sequential processes}}\]
\[q ::= p \; \mid \;  q\para q \; \mid \;  \restr{x}q \; \mid \;  X \; \mid \;  \recx q \; \; \; \mbox{  {\em processes} }\]

\noindent
where $\nil$ is the terminated process, $\mu.q$ is a sequential process where action $\mu$ (that
can be either an input $x(y)$ (or simply $x$), an output  $\bar{x}y$ (or simply $\bar x$) 
or a silent move $\tau$) is first performed and then $q$ is ready
({\em normal prefixing}), 
$ \underline{\mu}.q$  is a sequential process where action $\mu$  is {\em strongly prefixed} to $q$, meaning that 
$\mu$ is performed as the first action of an atomic action continuing with what $q$ can do, 
$p + p'$ is the sequential process obtained by the alternative composition of
sequential processes $p$ and $p'$, $q \para q'$ is the parallel composition 
of $q$ and $q'$, $\restr{x}q$ is process $q$ where the name $x$ is made private (restriction),
$X$ is a recursion variable and $\recx q$ is a recursive process.

The set ${\mathcal P}$ of {\em processes} contains those terms which are, w.r.t. recursion variables,
{\em closed}  (all the variables occur in a $rec$ binder) and {\em guarded} (all the variables occurring 
in the body $q$ of a recursion occurs inside a {\em normally prefixed} subprocess $\mu.q'$ of $q$). 
With abuse of notation, ${\mathcal P}$ will be ranged over by $p, q,\ldots$. 
%We call {\em closed systems} 
%those processes where all the names are restricted.
%We denote with  ${\mathcal P}_{seq}$ the set of  {\em sequential processes}.


The {\em free} names of a process $p$, $fn(p)$, are defined as usual. % (see Appendix A for more details).
The basic labels in $Act$ (ranged over by $\alpha$) are of three different kinds: the silent action 
$\tau$, the inputs of the form $xy$, the free and bound 
outputs of the form $\bar{x}y$ and $\bar{x}(y)$, respectively. 
These can be used for generating any sequence $\sigma$ of actions.
We assume that $\beta$ ranges over inputs and free outputs only.  
Given $\beta = xy$, $\bar\beta = \bar xy$ denotes the complement of $\beta$;
symmetrically, when $\beta = \bar xy$, $\bar\beta = xy$. 
The {\em free} and {\em bound} names of a label $\alpha$, $fn(\alpha)$ and 
$bn(\alpha)$, are defined as follows:
$fn(\tau) = bn(\tau) = \emptyset$, 
$fn(\bar{x}y) = fn(xy) = \{x,y\}$, 
$bn(\bar{x}y) = bn(xy) = \emptyset$, 
$fn(\bar{x}(y)) = \{x\}$, 
$bn(\bar{x}(y)) = \{y\}$. 
The names of $\alpha$ are $n(\alpha) = fn(\alpha)\cup bn(\alpha)$. These functions
are extended to any sequence $\sigma$ in the obvious way. For instance,
$fn(\epsilon) =  \emptyset$, $fn(\alpha\sigma) = fn(\alpha) \cup fn(\sigma)$.

%The definition of substitution of a name $y$ for a name $x$ in process $q$, denoted  $q\sost{y}{x}$, is
%standard (recalled in Appendix A). Similarly, the definition of substitution of a process $p$ for a recursion
%variable $X$ in process $q$, denoted  $q\sost{p}{X}$, is also standard (and recalled in Appendix A).


\section{Multi-$\pi$: High-level Semantics}\label{multi-hi}

The (early) operational semantics for the Multi-$\pi$-calculus is the labelled 
transition system $({\mathcal P},{\mathcal A}, \deriv{ })$, where the states are the processes
in ${\mathcal P}$, ${\mathcal A} = Act^*$ 
is the set of labels (ranged over by $\sigma$),
and $\deriv{ } \subseteq {\mathcal P}\times{\mathcal A}\times{\mathcal P}$ is the minimal 
transition relation generated by the rules listed in Table~\ref{rules}.

We briefly comment the rules that are less standard. 
Rules (S-in)--(S-out) allow for the creation of
transitions labelled by nonempty sequences of actions. 
In order for, e.g.,  $\underline{\overline{x}z}.q$ to make a move, it is
necessary that $q$ can perform a transition, i.e., the rest of the transaction. Hence, $\underline{\overline{x}z}.\nil$ 
cannot perform any action. If a transition is labeled by $\sigma = \alpha_1 \ldots \alpha_n$, then all the
actions $\alpha_1 \ldots \alpha_{n-1}$ are due to strong prefixes, while $\alpha_n$ to a
normal prefix.

Rule (Res) requires that no action in $\sigma$ can contain the restricted name $y$.
Rule (Cong) makes use of a structural congruence $\equiv$ on process terms induced by the 
following three equations:\footnote{We have taken the minimal set of equations that are needed
for giving a semantics ensuring associativity of parallel composition.}\\

$
(p \para q) \para r \; = \; p \para (q \para r)
$

$
\restr{x} (p \para q) = p \para \restr{x}q \; \; \mbox{ if $x \not\in fn(p)$}.
$

$
\restr{x} p =  \restr{y} (p\sost{y}{x})\; \;  \mbox{if $y \not\in fn(p)$}.\\
$

\noindent
(Cong) enlarges the set of transitions derivable from $p$, as Example \ref{multi-synch} shows. 
Moreover, it simplifies the mechanism of scope extrusion (i.e., there is no need of an explicit (Close) rule \cite{MPW}). 

Rule (Par) has a side condition 
that states that $p$ can perform $\sigma$ in the context of $q$ if the bound names of $\sigma$
do not clash with the free names of $q$, in order to avoid possible erroneous capture of names
in $q$. 

Rule (Com) has a side-condition on the possible
synchronizability of sequences $\sigma_1$ and $\sigma_2$. Relation $Sync(\sigma_1, \sigma_2, \sigma)$ holds
if $\sigma$ is obtained from an interleaving (possibly with synchronizations) of $\sigma_1$ and $\sigma_2$, 
where the last action of one of the two sequences is to be synchronized, hence reflecting that the 
subtransaction that ends first signals this fact (i.e., {\em commits}) to the other subtransaction.
Relation $Sync$ is formally defined by the inductive rules
reported in Table~\ref{sync}.

Rule (Open) states that whenever a
process wants to perform an output of a name $y$ which is actually restricted, then a bound
output is used to label the transition to remember that some {\em extrusion} (i.e., enlargement of
the scope of restriction) is now possible. Note that in the target state restriction disappears. 
The side-condition on applicability of the rule states 
that in $\sigma$ there must be an output of $y$ along some channel $x$, that function $Res(\sigma, y)$ is defined 
and its result is $\sigma'$.
Function $Res$ is formally defined in Table~\ref{restr}, where we assume that 
$z$ and $w$ are assumed different from $y$.
Note that, contrary to the semantics of the $\pi$-calculus \cite{MPW},
rule (Open) fixes the name of the bound output to the very same name of the restriction, namely $y$, instead of a fresh
name $w$, as there is no need to apply rule (Close) which is subsumed by (Com) due to structural congruence. Moreover,
due to (Cong), a restricted process $\restr{y}p$ may have infinitely many different transitions with a differently bound output,
one for any alpha-converted  $\restr{x} (p\sost{x}{y})$ with $x \not\in fn(p)$.

\begin{table}
\hrulefill\\[-.8cm]
{\renewcommand{\arraystretch}{2.8}
\begin{center}
$\begin{array}{lcllcl}
\mbox{(Tau)}  & \tau.p\deriv{\tau}p & & \mbox{(In)}  & x(z).p\deriv{xy}p\sost{y}{z} & y \notin fn(\restr{z}p)\\
\mbox{(S-tau)}  & \bigfrac{p\deriv{\sigma}p'}{\underline{\tau}.p\deriv{\sigma}p'} & 
& \mbox{(S-in)}  & \bigfrac{p\sost{y}{z}\deriv{\sigma}p'}{\underline{x(z)}.p\deriv{xy\sigma}p'} & y \notin fn(\restr{z}p)\\
\mbox{(Out)}  & \bar{x}y.p\deriv{\bar{x}y}p & & \mbox{(S-out)}  & \bigfrac{p\deriv{\sigma}p'}{\underline{\bar{x}y}.p\deriv{\bar{x}y\sigma}p'} & \\
\mbox{(Sum)}  & \bigfrac{p\deriv{\sigma}p'}{p+q\deriv{\sigma}p'} & &
\mbox{(Rec)} & \bigfrac{p\sost{\recx p}{X}\deriv{\sigma}p'}{\recx p\deriv{\sigma}p'}&  \\
\mbox{(Cong)} & \bigfrac{p \equiv p' \deriv{\sigma}q' \equiv q}{p\deriv{\sigma}q} & &
\mbox{(Res)}  & \bigfrac{p\deriv{\sigma}p'}{\restr{y}p\deriv{\sigma}
\restr{y}p'} & y\not\in n(\sigma) \\
\end{array}$

$\begin{array}{lcl}

\mbox{(Par)}  & \bigfrac{p\deriv{\sigma}p'}{p\para q\deriv{\sigma}p'\para
q} & bn(\sigma) \cap fn(q) = \emptyset  \\

\mbox{(Com)}  & \bigfrac{p\deriv{\sigma_1}p' \spazio q\deriv{\sigma_2}q'}{p
\para q \deriv{\sigma} p'\para q'} & Sync(\sigma_1, \sigma_2, \sigma)\\

\mbox{(Open)}  & \bigfrac{p\deriv{\sigma}p'}{\restr{y}p\deriv{\sigma'}
p'} & \exists \bar xy \in \sigma, \;  \mbox{ and }  \; Res(\sigma, y)= \sigma'  \;    \\

\end{array}$

\hrulefill
\end{center}}
\caption{SOS rules (symmetric rules  of (Sum) and (Par) omitted)}\label{rules}
\end{table}

\begin{table}
\hrulefill\\[-.8cm]
\begin{center}
$\begin{array}{lcl}
Sync(\beta, \bar{\beta}, \tau) &  \bigfrac{\sigma \neq \epsilon}{Sync(\beta\sigma, \bar{\beta}, \sigma)} &
\bigfrac{\sigma \neq \epsilon}{Sync(\beta, \bar{\beta}\sigma, \sigma)} \\
\bigfrac{Sync(\sigma_1, \sigma_2, \sigma)}{Sync(\beta\sigma_1, \bar{\beta}\sigma_2, \sigma)} &
 \bigfrac{Sync(\sigma_1, \sigma_2, \sigma)}{Sync(\beta\sigma_1, \sigma_2, \beta\sigma)} & 
 \bigfrac{Sync(\sigma_1, \sigma_2, \sigma)}{Sync(\sigma_1, \beta\sigma_2, \beta\sigma)} \\
\end{array}$
\end{center}

\hrulefill%\\[-.4cm]
\caption{Synchronization relation}\label{sync}
\end{table}


\begin{table}
\hrulefill\\[-.7cm]
{\renewcommand{\arraystretch}{3}}

\begin{center}
$\begin{array}{llllllllllll}
Res(\epsilon, y)  =  \epsilon & \; \;  \;
Res(xy \sigma, y) =  \undef  & \; \; \;  Res(yx \sigma, y)  =  \undef & \; \; \;
Res(zw \sigma, y)  =  zw Res(\sigma, y) \\
\end{array}$
$\begin{array}{llllllllllll}
Res(\bar zy \sigma, y) =  \bar z(y) \sigma & \; \;  \;  Res(\bar zw \sigma, y)  =  \bar zw Res(\sigma, y) & \; \; \;
Res(\bar yx \sigma, y)  =  \undef  \\[-.7cm]
\end{array}$
\end{center}

\hrulefill
\caption{Restriction relation $Res$ -- $z$ and $w$ are assumed different of $y$.}\label{restr}
\end{table}

The semantics we have presented is called {\em early} because in rules (In) and (S-in) the name $z$ is replaced by name $y$ at
this syntactical level, and then rule (Com) -- via $Sync$ --  simply matches that the sent values and the chosen 
input values are actually the same. A different discipline, called {\em late} semantics, could be 
adopted, according to which the substitution takes place only at the level of rule (Com).
See, e.g., \cite{SW} for more details. 

\begin{example}\label{multi-synch}{\bf (Multi-party synchronization)} Assume we have three processes that want to synchronize. 
This can be easily expressed in Multi-$\pi$. E.g., consider processes $p = \underline{a}.a.p'$ -- which is the leader of the synchronization --
$q = \bar{a}.q'$ and $r = \bar{a}.r'$ and the whole system $P = \restr{a}((p \para q) \para r)$. It is easy to observe
that $P \deriv{\tau} \restr{a}((p' \para q') \para r')$, so the three processes have synchronized in one single atomic transition.
It is interesting to observe that $P' = \restr{a}(p \para (q \para r))$ could not
perform the multiway synchronization if the structural congruence (Cong) were not allowed.
\fine
\end{example}

\begin{example}\label{trans-synch}{\bf (Transactional synchronization)} Assume we have two processes that wants to synchronize
on a sequence of actions. 
This can be easily expressed in Multi-$\pi$. E.g., consider processes $p = \underline{a}.a.p'$ and
$q =\underline{\bar{a}}.\bar{a}.q'$ and the whole system $P = \restr{a}(p \para q)$. It is easy to observe
that $P \deriv{\tau} \restr{a}(p' \para q')$, so the two processes have synchronized in one single atomic transaction.
Of course, it is possible to define transactional multi-party synchronization as well. For instance,  
$p =\underline{\bar{a}}.\bar{b}.p'$ and $q = \underline{b}.\bar{a}.q'$, $r = \underline{a}.a.r'$, and the whole system $Q =
 \restr{a}((p \para q) \para r) \deriv{\tau} \restr{a}((p' \para q') \para r')$.
\fine
\end{example}

\begin{example}\label{guarded-rec}{\bf (Guardedness)} We have assumed that each 
recursion variable occurring 
in the body $q$ of a recursion occurs inside a  normally prefixed subprocess $\mu.q'$ of $q$. 
This will prevent infinitely branching sequential processes.
For instance, consider the non legal process $p = \recx {(\underline{a}.X + b.\nil)}$.
According to the operational rules, $p$ has infinitely many transitions leading to $\nil$, each one with a label of the form $a^nb$, for 
$n = 0, 1, ...$. 
%In fact, with the condition of guardedness, the set of terms generated by the following grammar
%defines the set of transition systems labeled on $Act^+$ with finitely many states and transitions:
%
%$p ::= \nil \mid  \mu.p \mid  \underline{\mu}.p \mid p+p  \mid  X \mid \recx p$
\fine
\end{example}

Processes of Multi-$\pi$ are equipped with an observational semantics, given in terms of
a strong bisimulation-based equivalence \cite{Mil89}, where we have to be careful about 
the free and bound names that are
involved, in order to avoid the capture of free names. 

\begin{definition}
A binary symmetric relation $R$ over the set ${\mathcal P}$ of process terms is an {\em early bisimulation}
if
$(p,q)\in R$ implies:
\begin{itemize}
\item
if $p\deriv{\sigma}p'$ and $bn(\sigma)\cap fn(p,q) = \emptyset$
there exists then $q'$ such that
$q\deriv{\sigma}q'$ and $(p',q')\in R$.
%\item
%symmetrically for $q$ derivations.
\end{itemize}
Two process terms $p$ and $q$ are {\em bisimilar}, written
$p\sim q$, if there exists an (early) bisimulation $R$ such that $(p,q)\in R$.
\fine
\end{definition}

\begin{proposition}\label{prop1}
Let $p, q \in {\mathcal P}$ be processes. If $p \equiv q$ then $p \sim q$.
\fine
\end{proposition}

Besides the three equations defining the structural congruence $\equiv$, other interesting laws hold for
bisimulation equivalence.

\begin{proposition}\label{prop2}
Let $p, q, r \in {\mathcal P}$ be processes. Then the following holds:

$\begin{array}{llll}
(1) & (p + q) + r \; \sim \; p + (q +r)  &
(2) & p + q\; \sim \; q + p  \\
(3) & p + \nil \; \sim \;  p  &
%(4) & p \para (q \para r) \; \sim \; (p \para q) \para r  \\
(4) & p \para q\; \sim \; q \para p  \\
(5) & p \para \nil \; \sim \;  p  &
%(7) & \restr{x}(p \para q) \; \sim \;  p \para \restr{x}q \mbox{  if } x \not\in fn(p) &
(6) & \restr{x}\restr{y}p \; \sim \;  \restr{y}\restr{x}p \\
%(9) & \restr{x}p \; \sim \;  \restr{y} (p\sost{y}{x}) \mbox{  if } y \not\in fn(p) & \\
(7) & x(y).p \; \sim x(z).(p\sost{z}{y}) \mbox{  if } z \not\in fn(p) &
(8) & \restr{x} \nil \; \sim \; \nil\\
\end{array}$

\proof 
The proof is standard. E.g., for (2) it is enough to prove that relation $R = \{ ((p+q),(q+p) \mid p,q \in   {\mathcal P} \} \cup 
\{ (p,p) \mid p \in  {\mathcal P} \} $ is a strong bisimulation.
\fine
\end{proposition}

As expected, the sum operator is associative, commutative and $\nil$ absorbent. 
Commutativity of restriction (case (6) above) allows for
a simplification in the notation that we usually adopt: restriction on a set of names, e.g., $\restr{x,y}p$.
The parallel operator is
commutative and $\nil$ absorbent, but associative only because of the addition of the structural congruence
and the associated rule (Cong).

A few properties of strong prefixing are as follows:

\begin{proposition}\label{prop}
Let $p, q \in {\mathcal P}$ be processes. Then the following holds:

$\begin{array}{lllllr}
(1) & \underline\mu.(p + q)  \; \sim \;   \underline\mu.p +  \underline\mu.q & \; \;
(2) &  \underline\mu.\nil  \; \sim \;   \nil & \; \;
(3) &  \underline\tau.p   \; \sim \;  p \\
\end{array}
$
%\proof 
%The proof is standard.
\fine
\end{proposition}

%A full treatment of the axiomatic properties of strong prefixing are outside the scope of this paper; more 
%can be found in \cite{GM90,Gor92}.



\section{Case studies}\label{multi-ex}

\begin{example}\label{patil} {\bf (Cigarette smokers' problem)}
This problem, proposed by Patil in \cite{Pat71}, is a typical instance
of a problem for which no deadlock-free and livelock-free solution seems to exist in $\pi$-calculus.
Here is its description, according to \cite{Pet81}.
The problem consists of  four processes: an agent and three smokers. Each smoker continuously makes a 
cigarette and smokes it. But to make a cigarette, three ingredients are needed: tobacco, paper and matches.
One of the smokers has paper, another tobacco and the third has matches. The agent has an infinite supply
of all three. The agent places two of the ingredients on the table. The smokers who has the remaining ingredient
can then make and smoke a cigarette, signalling the agent upon completion. The agent then puts out 
another two of the three ingredients and the cycle repeats. The problem is to define the code for the smoker
processes to determine which of the three processes should proceed (the agent is fixed and cannot be changed).
Clearly, a solution to the problem is to have an atomic transaction in which the agent synchronize
only with the smoker that has the missing ingredient.

$
\begin{array}{lcl}
Agent &  \eqdef & \recx{ \tau.(\underline{\overline{tob}}.\overline{mat}.end.X) + 
\tau.(\underline{\overline{mat}}.\overline{pap}.end.X) + \tau.(\underline{\overline{pap}}.\overline{tob}.end.X)} \\
S_{pap} &  \eqdef & rec X.\underline{tob}.mat.smoke.\overline{end}.X \\ 
S_{tob} &  \eqdef & rec X.\underline{mat}.pap.smoke.\overline{end}.X \\ 
S_{mat} &  \eqdef & rec X.\underline{pap}.tob.smoke.\overline{end}.X \\ 
Patil & \eqdef & \restr{\,tob,pap,mat,end}(Agent \para S_{tob} \para S_{mat} \para S_{pap})
\end{array}
$

This solution, based on transactional synchronization, determines a finite-state labeled transition systems, but it is somehow not really compliant to
the specification of the problem, where the ingredients are not treated as resources that are consumed and then reproduced. A more faithful representation of the problems is as follows:

$
\begin{array}{lcl}
Agent' &  \eqdef & \recx{ \tau.(\overline{tob}.\nil \para \overline{mat}.\nil \para end.X) + 
\tau.(\overline{mat}.\nil \para \overline{pap}.\nil \para end.X) }  + \, \tau.(\overline{pap}.\nil \para \overline{tob}.\nil \para end.X) \\
%S_{tob} &  \eqdef & rec X.\underline{mat}.pap.smoke.\overline{end}.X \\ 
%S_{mat} &  \eqdef & rec X.\underline{pap}.tob.smoke.\overline{end}.X \\ 
%S_{pap} &  \eqdef & rec X.\underline{tob}.mat.smoke.\overline{end}.X \\ 
Patil' & \eqdef & \restr{\,tob,pap,mat,end}(Agent' \para S_{tob} \para S_{mat} \para S_{pap})
\end{array}
$

where a multi-party synchronization takes place among a smoker and the two needed ingredients.
This solution, however, generates an infinite-state transition system. \footnote{Note, however, that,
by adding the equation $p \para \nil = p$
to those defining the structural congruence $\equiv$ and by identifying congruent states, the resulting
labeled transition systems would be finite.}
%Nonetheless, in \cite{GMV10}
%we show that Multi-$\pi$ can be equipped with a Petri nets semantics in the style of \cite{BG09,GV10}
%and the net model for $Patil'$ is a safe finite P/T net, hence with a finite-state interleaving marking graph.

Patil showed in \cite{Pat71} that no sequence of $P$ and $V$ operations \cite{Dij68} can correctly solve this problem.
The reason is that $P$ and $V$ operations offer binary synchronization only, while this problem requires
a transactional synchronization (first version) or a multiparty sycnhronization (second version). 
Following the same argument of Patil, one can give evidence
supporting the claim that this problem cannot be solved in the $\pi$-calculus. A recent paper \cite{LV10} also 
gives further support to our claim, as there it is proved that there is an expressivity gap between binary 
CCS-based synchronization and ternary synchronization, as required by (the second version of) this example. 
\fine
\end{example}

\begin{example}\label{ex-polite}
{\bf(The Polite Dining Philosophers)} This alteration of the famous problem, originally proposed
in \cite{Dij71}, is as follows.
Five philosophers seat at a round table, with a private plate and where each of the five forks is private to one
philosopher and can be shared, upon request, to the neighbor philosopher.
Philosophers can think and eat; in order to eat, a philosopher has to acquire both forks, his 
private one (the left one) and the one of his right neighbor,
All philosophers behave the same, so the problem is intrinsically symmetric.
Clearly a na\"ive solution would cause deadlock exactly when all five philosophers take their private fork 
at their left at the same time and are waiting for the fork at their right.
A simple solution is to force atomicity on the acquisition of the two forks so that either both are taken or none. 
The forks can be defined as

$
\begin{array}{lll}
fork_i \eqdef  \recx { \overline{up_i}.\overline{dn_i}.X} \; \;  \mbox{   for  }i = 0, \ldots 4  
\end{array}
$

\noindent
The philosophers can be described as 

$
\begin{array}{lll}
phil_i &  \eqdef & \recx (think.X 
 + \underline{up}_i.\underline{req}_{i+1}(x).\underline{x}.eat.\underline{dn}_{i}.\underline{rel}_{i+1}(y).\underline{y}.X \\
&& \; \; \;  \hspace{2cm} + \overline{req}_i up_i. \rec Y (think.Y +  \overline{rel}_i dn_i.X))
\end{array}
$

\noindent
for  $i = 0, \ldots 4$, where $i+1$ is computed modulo $5$. 
For simplicity,
we assume also that the release of the two forks is atomic, but this is not necessary for correctness.
The whole system is 

$
\begin{array}{lll}
P_i \;  \eqdef \;  \restr{\, up_i, dn_i}(phil_i \para fork_i)   \; \;  \mbox{   for  }i = 0, \ldots 4 \\
DF \;  \eqdef \;  \restr{\,L}(P_0 \para P_1 \para P_2 \para P_3 \para P_4) 

\end{array}
$

\noindent
where $L = \{req_i, rel_i \mid i = 0, \ldots 4 \}$. Note that the semantics generates 
a finite-state labeled transition system for $DF$. 
This kind of solution
to the dining philosophers problem cannot be given in a language which admits binary communication only,
such as the $\pi$-calculus, according to \cite{LR81,LV10}.
\fine
\end{example}

\begin{example}\label{ex-mobile-finance}
{\bf(Mobile Transaction)} Let us now consider a variation of the mobile telephone example in \cite{Mil99}.
Here a car, with a mobile phone on it, is moving and the service to the mobile phone is granted
by one of the two base stations. Each base station is linked to a centre, which handles the stream of data coming from the base stations.
In the following example, the mobile phone on the car modeled by $CAR$, is linked to $BASE$, so to represent a call in progress: the exchange of data between the phone and the base occurs on
channel $t_1$. At some point, as a consequence of the movement of the car, the phone detects (on channel $sgn$) the presence of the (presumably stronger) wireless signal $b_2$ of another base station, represented by $IDLEBASE$. In order to continue the call in progress, it starts a transaction 
with the aim of switching the communication stream from the current $BASE$ to the closer $IDLEBASE$.
The transaction is opened by sending the detected signal $b_2$ (used later on as a channel) to
$BASE$, which forwards the switch request over channel $c$ to the $CENTRE$, by specifying first the channel $b_1$ of the current $BASE$, and then the channel $b_2$ of the $IDLEBASE$ that is going to
support the communication of the mobile phone. The $CENTRE$ creates a new channel $t$ over which the
voice data stream between $CAR$ and $IDLEBASE$ is going to flow, and communicates it first over channel $b_2$ to $IDLEBASE$ (which becomes active as $BASE$) and then over $b_1$ to the current $BASE$,
which in turn forwards it to the $CAR$. The whole system is represented by the following code:
\[\begin{array}{l}
(\nu\, c, sgn, t_{i}, b_{i}, i=1,2) \\[1mm]
\big(\;\rec{CAR}(t_1.CAR + \\[1mm] 
\phantom{\big(\;\rec{CAR}(} \underline{sgn(b_2)}.\underline{\overline{b_1} b_2}.b_1(t_2).
          \rec{CAR'}(t_2.CAR' + \\[1mm] 
\phantom{\big(\;\rec{CAR}(\underline{sgn(b_2)}.\underline{\overline{b_1} b_2}.b_1(t_2).
          \rec{CAR'}(} \underline{sgn(b_1)}.\underline{\overline{b_2}b_1}.b_2(t_1).CAR ))
 \;\; \para \\[1mm]
\phantom{\big(} \rec{BASE}(\overline{t_1}.BASE + \\[1mm]
\phantom{\big( \rec{BASE}(} \underline{b_1(b_2)}.\underline{\overline c b_1}.\underline{\overline c b_2}.\underline{b_1(t_2)}.\overline{b_1}t_2. \\[1mm]
\phantom{\big( \rec{BASE}(} \rec{IDLEBASE}(\overline{sgn}b_1.IDLEBASE + b_1(t_1).BASE) ) \;\; \para \\[1mm]
\phantom{\big(} \rec{IDLEBASE}( \overline{sgn}b_2.IDLEBASE +
  b_2(t_2). \\[1mm] \qquad
  \rec{BASE}(\overline{t_2}.BASE + \underline{b_2(b_1)}.\underline{\overline c b_2}.
\underline{\overline c b_1}. \underline{b_2(t_1)}.\overline{b_2}t_1.IDLEBASE)) \;\; \para \\[1mm]
\phantom{\big(} \rec{CENTRE}(\underline{c(b_1)}.\underline{c(b_2)}.\restr{t}
(\underline{\overline{b_2}t}.\overline{b_1}t.CENTRE)) \big)
\end{array}\]

Strong prefixing allows us to represent the whole process of stream switching from one $BASE$ to the other as an atomic transaction, so that there is %would be 
no need to handle explicitly the possible race condition occurring when two distinct $CAR$s try to switch their communication to the 
same $IDLEBASE$.
\fine


%  The caller can also start a financial transaction with a bank, consisting
% of a request (action $can$) and by a $write$ operation. These two operations can be served by different
% base stations.

% \[\begin{array}{l}
% (\nu\, talk_{i}, switch_{i}, give_{i}, alert_{i}, i=1,2) \\
% (\rec{CAR}{(talk_{1}.CAR + \underline{\overline{can}}.(\overline{write}.CAR + \\
% \underline{switch}_{1}(talk_1,switch_1).\overline{write}.CAR)
% + switch_{1}(talk_1,switch_1).CAR)} | \\
% \rec{BASE_{1}}{(\overline{talk}_{1}.BASE_{1} + lose_{1}(t,s).\overline{switch}_{1}
% \langle t,s\rangle.gain_{1}.BASE_{1})} | \\
% \rec {BASE_{2}}{(\overline{talk}_{2}.BASE_{2} + lose_{2}(t,s).\overline{switch}_{2}
% \langle t,s\rangle.gain_{2}.BASE_{2})} | \\
% \rec{BANK}{can.write.BANK} \\
% \rec{CENTRE}{(\overline{lose}_{1}\langle talk_{2},switch_{2}\rangle.
% \overline{gain}_{2}.\overline{lose}_{2}\langle talk_{1},switch_{1}\rangle.}\\
% \overline{gain}_{1}.CENTRE))
% \end{array}\]
% \fine


\end{example}


%\newpage

\section{Expressiveness\\[-.6cm]}\label{multi-expr}
In this section we analyze the expressiveness of Multi-$\pi$ in different respects. We first show that the 
strong prefixing operator is extremely powerful, in fact it allows us to derive several other operators straightforwardly.
Next we show that such operator, although very expressive, is {\em not} powerful enough to solve the {\em Last Man Standing},
a problem of distributed computing introduced in \cite{VBG09}, apparently solvable only by calculi with inherent centralized
implementation of parallel composition.

These results strengthen the argument that strong prefixing is the best trade-off
between the expressiveness gained by a concurrent calculus and the effective parallelism that it can still retain.

\subsection{Choice}
% l'operatore di scelta e' _totalmente_ derivato, nel momento in cui non ci interessa una traduzione a reti di petri in stile BG
Strong prefixing can be exploited to give an encoding of the choice operator equivalent with respect to strong bisimilarity, so that Multi-$\pi$ turns out to be,
to some extent, redundant. The encoding of the choice is based on the same idea first presented in \cite{NP96}, except that,
thanks to strong prefixing, there is no need of separating input and output choices, nor of taking care of symmetry and convergence, which
are all preserved. For example, if we want to
encode the process $s = x(y).p' + \bar{w}z.q'$ in a process $s'$ without choice operator, 
we can split the choice in two parallel processes $p$ and $q$ sharing a private channel $c$, over which a third 
process $r$ acts as a semaphore:
\[ s' = \restr{c} ( p \para q \para r ) = \restr{c} ( \underline{c}.x(y).p' \para \underline{c}.\bar{w}z.q' \para \bar{c} ) \]
The observable behavior of $s$ and $s'$ is exactly the same, in fact both allow the transitions $\deriv{x(y)}p'$ and 
$\deriv{\bar{w}z}q'$. The only (formally unobservable) difference between them is the deadlocked garbage left by $s'$.
In general, the encoding of $\mu_1.p_1 + \mu_2.p_2 + \ldots + \mu_n.p_n$ becomes
$ \restr{c} ( \underline{c}.\mu_1.p_1 \para \underline{c}.\mu_2.p_2 \para \cdots \para \underline{c}.\mu_n.p_n \para \bar{c} )$. We can formalize this encoding as follows:

\begin{proposition} Let Multi-$\pi^{-c}$ be the language Multi-$\pi$ without choice operator and let $\encoding c { \cdot }$ be the function from Multi-$\pi$ to Multi-$\pi^{-c}$ processes
defined homomorphically with respect to all the operators, except for choice as follows:
\[ \encoding c { p_1 + p_2 }  = \restr x ( \overline{x} \para \encoding c {p_1} _x \para \encoding c {p_2} _x ) \qquad x \notin fn(p_1 + p_2) \]
with $\encoding c { \cdot }_x$ defined over sequential processes as
\begin{align*}
\encoding c { \mathbf 0 }_x  &= \mathbf 0 \quad &
\encoding c { \mu.q }_x  &= \underline{x}.\mu.\encoding c q \quad \\
\encoding c { \underline{\mu}.q }_x  &= \underline{x}.\underline{\mu}.\encoding c q &
\encoding c { p_1 + p_2 }_x \;  &= \; \encoding c {p_1}_x \para \encoding c {p_2}_x  
\end{align*}
% \begin{align*}
% \encoding c { q_1 \para q_2 } \; & = \; \encoding c {q_1} \para \encoding c {q_2} & \quad & &
% \encoding c { \restr x q } \; & = \; \restr x \encoding c q  & \quad & &
% \encoding c { X } \; & = \; X \\
% \encoding c { \rec X q } \; & = \; \rec X {\encoding c q} & & & 
% \encoding c { \mathbf 0 } \; & = \; \mathbf 0 & & &
% \encoding c { \mu.q } \; & = \; \mu.\encoding c q  \\
% \encoding c { \underline{\mu}.q } \; & = \; \underline{\mu}.\encoding c q 
% \end{align*}
Then, for every process $q$ of Multi-$\pi$, $q \sim \encoding c q$.
\fine
\end{proposition}


% \subsection{Sequential composition}
% Sequential composition of $p$ and $q$, denoted $p;q$, is a very powerful operator included in ACP \cite{BK84}, whose
% semantics is described by the following rules
% 
% $\begin{array}{llllll}
% \mbox{(Seq$_1$)} \; \bigfrac{p\deriv{\sigma}p'}{p;q \deriv{\sigma} p';q} & \qquad &
% \mbox{(Seq$_2$)} \; \bigfrac{p\deriv{\surd}p' \spazio q\deriv{\sigma}q'}{p;q \deriv{\sigma}  q'}
% \end{array}$
% 
% where the distinguishing action $\surd$ indicates successful termination. 
% Milner showed in \cite{Mil89} how to mimic sequential composition in CCS as follows, where
% also parallel composition is to be modified in order to take care of the synchronous nature of action $\surd$:
% 
% $\begin{array}{lllllllll}
% p;q & = & \restr{a}(p\sost{a}{\surd} \para a.q) \\
% p \| q & = & \restr{d_1,d_2}(p\sost{d_1}{\surd} \para q\sost{d_2}{\surd} \para (d_1.d_2.\surd + d_2.d_1.\surd))
% \end{array}$
% 
% However, this translation is not in full agreement with the operational rules above, but we can take advantage of strong prefixing
% of Multi-$\pi$ to get this result as follows:
% 
% $\begin{array}{lllllllll}
% p;q & = & \restr{a}(p\sost{a}{\surd} \para \underline{a}.q) \\
% p \| q & = & \restr{d_1,d_2}(p\sost{d_1}{\surd} \para q\sost{d_2}{\surd} \para 
% (\underline{d_1}.\underline{d_2}.\surd + \underline{d_2}.\underline{d_1}.\surd))\\
% p \| q & = & \restr{d}(p\sost{d}{\surd} \para q\sost{d}{\surd} \para \underline{d}.\underline{d}.\surd)
% \end{array}$
% 
% {\bf mi pare che basti anche l'ultima versione con una sola azione $d$, ma deve esserci un motivo per volerne due,
% altrimenti non capisco perche'Milner ne voglia due.}

\subsection{Polyadic $\pi$-calculus}
Polyadic communication -- consisting in the atomic transmission of an arbitrary number $n$ of names over some channel $x$ --
can be easily obtained thanks, again, to strong prefixing. The easiest and correct encoding is (a strong prefixing-based variation of) 
the one considered in \cite{Mil91}
for the standard $\pi$-calculus: for example, the transmission of the pair of names $a_1, a_2$ over channel $x$ (written in polyadic
form as $\bar{x} \langle a_1,a_2 \rangle$ for the output and $x(z_1,z_2)$ for the input) can be implemented by first communicating a fresh, private channel name $c$, and then sending over $c$ the intended names:
\[ \restr{c} (\underline{\bar{x}c}.\underline{\bar{c}a_1}.\bar{c}a_2.p') \para
			 \underline{x(y)}.\underline{y(z_1)}.y(z_2).q' \deriv{\tau} \restr{c} (p' \para q'\{a_1/z_1,a_2/z_2\}) \]
provided that $c, y$ do not appear free in $q'$. The encoding of a choice between two or more polyadic actions, 
e.g. $\bar{x_1} \langle a_1,a_2 \rangle + \bar{x_2} \langle a_3,a_4 \rangle$, can be obtained by using just one 
private name $c$ for all the mutually exclusive actions: this allows both the minimization of the number 
of private names needed for the encoding and the conformity to the grammar of Multi-$\pi$, that forbids creation 
of private names directly in the branches of the choice operator.

It is worth remarking that strong prefixing extinguishes any problem of channel typing, deriving from the need of preventing polyadic 
communication between those pairs of processes whose number of transmitted (resp. received) names does not match with the number
of names of the receiver (resp. sender). For example, the encoding of the pair $p = \bar{x} \langle a_1,a_2,a_3 \rangle$ and $q = x(z_1,z_2)$
would lead to the unintentional deadlock of the process $p$ in the absence of channel typing or strong prefixing. 

Formally, the encoding of polyadic communication by means of strong prefixing does not provide processes strictly equivalent, because of the different observables. However, the semantics of the original process is preserved in terms of full abstraction with respect to strong bisimilarity:

\begin{proposition} Let Multi-$\pi^{+pc}$ be the language Multi-$\pi$ with the addition
of polyadic communication, that is with prefixes of the form 
$ \mu' = \tau \;|\; x(y_1, \ldots, y_n) \;|\; \overline x \langle y_1, \ldots, y_n \rangle $ for any $n \in \nat$ and SOS rules generalized accordingly (for details, see Appendix A). Let also $\encoding {pc} { \cdot }$ be the function from Multi-$\pi^{+pc}$ to Multi-$\pi$ processes
defined homomorphically with respect to terminated process, parallel composition, restriction, process variable and recursion, and defined as follows for the remaining operators:
\begin{align*}
\encoding {pc} { p_1 + p_2 }  &= \restr x ( \encoding {pc} {p_1} _x + \encoding {pc} {p_2} _x ) & & x \notin fn(p_1 + p_2) \\
\encoding {pc} { \mu'.q }  &= \restr x ( \encoding {pc} {\mu'.q} _x ) & & x \notin fn(\mu'.q) , \; \mu' = \overline z \langle y_1, \ldots, y_n \rangle \\
\encoding {pc} { \underline{\mu}'.q }  &= \restr x ( \encoding {pc} {\underline{\mu}'.q} _x ) & & x \notin fn(\underline{\mu}'.q) , \; \underline{\mu}' = \underline {\overline z} \langle y_1, \ldots, y_n \rangle \\
\encoding {pc} { \mu'.q }  &=  \encoding {pc} {\mu'.q} _{x} & & \mu' =  z(y_1, \ldots, y_n)  \text{ or } \mu' = \tau \\
\encoding {pc} { \underline{\mu}'.q }  &=  \encoding {pc} {\underline{\mu}'.q} _{x} & & \underline{\mu}' =  \underline z (y_1, \ldots, y_n)  \text{ or } \underline{\mu}' = \underline \tau
\end{align*}
with $\encoding {pc} { \cdot }_{x}$ defined as
\begin{align*}
\encoding {pc} { \tau.q }_x  &= \tau.\encoding {pc} q  \\
\encoding {pc} { \underline \tau.q }_x  &= \underline \tau.\encoding {pc} q  \\
\encoding {pc} { z(y_1, \ldots, y_n).q }_x  &= 
\underline{z(w)}.\underline{w(y_1)}. \cdots .\underline{w(y_{n-1})}.w(y_n).\encoding {pc} q \\
\encoding {pc} { \underline z(y_1, \ldots, y_n).q }_x  &= 
\underline{z(w)}.\underline{w(y_1)}. \cdots .\underline{w(y_{n-1})}.\underline{w(y_n)}.\encoding {pc} q \\
\encoding {pc} { \overline z \langle y_1, \ldots, y_n \rangle .q }_x  &= 
\underline{\overline zx}.\underline{\overline xy_1}. \cdots .\underline{\overline xy_{n-1}}.\overline xy_n.\encoding {pc} q \\
\encoding {pc} { \underline {\overline z} \langle y_1, \ldots, y_n \rangle .q }_x  &= 
\underline{\overline zx}.\underline{\overline xy_1}. \cdots .\underline{\overline xy_{n-1}}.\underline{\overline xy_n}.\encoding {pc} q \\
\encoding c { p_1 + p_2 }_x &= \encoding c {p_1}_x + \encoding c {p_2}_x  
\end{align*}
Then, for every pair of processes $q_1, q_2$ of Multi-$\pi^{+pc}$, $q_1 \sim q_2 \iff \encoding {pc} {q_1} \sim \encoding {pc} {q_2} $.
\end{proposition}
It is worth noticing that the parameter $x$ of the function $\encoding {pc} \cdot _x$ is not used in the encoding of the 
input and silent action.



\subsection{Polyadic Synchronization}
Polyadic synchronization \cite{CM03} extends a language by structuring channels: instead of being composed of just one name,
each channel can be represented by a tuple of names $x_1@x_2@\ldots@x_k$ of arbitrary length. 
The synchronization between two processes is consequently allowed only if each name $x_i$ of the output action matches with the
corresponding name of the input action, so that, for example, the two processes $p = \bar{x}@\bar{y}\langle a \rangle.p'$ and $q = x@y(z).q'$ are allowed to communicate, while $p$ and $r = x@w(z).r'$ are not allowed, provided that $y \neq w$.

Polyadic synchronization can be encoded as a sequence of strong-prefixed synchronizations over the names $x_i$ which compose the channel.
In order to avoid interference with other processes, each sequence must be opened with a communication 
over a channel representing the arity of the synchronization (in order to avoid that a sender synchronize with more than one receiver) 
and closed with a synchronization check over a fresh, private name $c$ that has been transmitted at each step of the sequence (in 
order to be sure that all the received messages are from the same sender). The above processes $p$ and $q$ can be encoded as follows:
\[ \restr{c} (\underline{\overline{two}c}.\underline{\bar{x}c}.\underline{\bar{y}c}.\bar{c}a.p' \para \underline{two(w)}.\underline{x(w')}.\underline{y(w'')}.\underline{w''(z)}.(\underline{w}.w.q' \para \overline{w'} \para \overline{w''})) \; \; \deriv{\tau}  \; \;
\restr{c} (p' \para q'\sost{a}{z} \para \nil \para \nil)
\]
with $two, c, w, w', w''$ not appearing free in $q'$. The first synchronization over the channel $two$ ensures that the processes involved in the polyadic synchronization are ready to synchronize over the same number of names, while the last sequence of synchronizations over $w, w', w''$ ensures that all these names correspond to instances of the same private name $w$ repeatedly sent by the same sender process, which excludes any interference by some other process trying to perform an output action over $x$ and/or $y$.

Observationally, we obtain a similar result as for polyadic communication:

\begin{proposition} Let Multi-$\pi^{+ps}$ be the language Multi-$\pi$ with the addition
of polyadic synchronization, that is with prefixes generalized as  $ \mu' = \tau \;|\; x_1@\ldots@x_n(y) \;|\; \overline {x_1@\ldots@x_n} \langle y \rangle $ for any $n \in \nat$ and SOS rules generalized accordingly (for details, see Appendix B). Let also $\encoding {ps} { \cdot }$ be the function from Multi-$\pi^{+ps}$ to Multi-$\pi$ processes
defined homomorphically with respect to terminated process, parallel composition, restriction, process variable and recursion, and defined as follows for the remaining operators:
\begin{align*}
\encoding {ps} { p_1 + p_2 }  &= \restr x ( \encoding {ps} {p_1} _x + \encoding {ps} {p_2} _x ) & & x \notin fn(p_1 + p_2) \\
\encoding {ps} { \mu'.q }  &= \restr x ( \encoding {ps} {\mu'.q} _x ) & & x \notin fn(\mu'.q) , \; \mu' = \overline {z_1@\ldots@z_n} \langle y \rangle \\
\encoding {ps} { \underline{\mu}'.q }  &= \restr x ( \encoding {ps} {\underline{\mu}'.q} _x ) & & x \notin fn(\underline{\mu}'.q) , \; \underline{\mu}' = \underline {\overline {z_1@\ldots@z_n}} \langle y \rangle \\
\encoding {ps} { \mu'.q }  &=  \encoding {ps} {\mu'.q} _{x} & & \mu' =  z_1@\ldots@z_n(y)  \text{ or } \mu' = \tau \\
\encoding {ps} { \underline{\mu}'.q }  &=  \encoding {ps} {\underline{\mu}'.q} _{x} & & \underline{\mu}' =  \underline {z_1@\ldots@z_n}(y)  \text{ or } \underline{\mu}' = \underline \tau
\end{align*}
with $\encoding {ps} { \cdot }_{x}$ defined as
\begin{align*}
\encoding {ps} { \tau.q }_x  &= \tau.\encoding {ps} q  \\
\encoding {ps} { \underline \tau.q }_x  &= \underline \tau.\encoding {ps} q  \\
\end{align*}
\begin{align*}
\encoding {ps} { z_1@\ldots@z_n(y).q }_x  &= 
\underline{n(w_0)}.\underline{z_1(w_1)}. \cdots . \underline{z_n(w_n)}.\underline{w_n(y)}. & w_i \notin fn(q) \\
   & \qquad (\underbrace{\underline{w_0}. \cdots . \underline{w_0}}_{n - 1}.w_0.\encoding {ps} q \para \overline w_1 \para \cdots \para \overline w_n )  \\
\encoding {ps} { \underline {z_1@\ldots@z_n}(y).q }_x  &= 
\underline{n(w_0)}.\underline{z_1(w_1)}. \cdots . \underline{z_n(w_n)}.\underline{w_n(y)}.  & w_i \notin fn(q) \\
   & \qquad (\underbrace{\underline{w_0}. \cdots . \underline{w_0}}_{n}.\encoding {ps} q \para \overline w_1 \para \cdots \para \overline w_n )  \\
\encoding {ps} { \overline {z_1@\ldots@z_n} \langle y \rangle .q }_x  &= 
\underline{\overline {n} x}.\underline{\overline {z_1} x}. \cdots . \underline{\overline {z_n} x}. \overline{x} y. \encoding {ps} q \\
\encoding {ps} { \underline {\overline {z_1@\ldots@z_n}} \langle y \rangle  .q }_x  &= 
\underline{\overline {n} x}.\underline{\overline {z_1} x}. \cdots . \underline{\overline {z_n} x}. \underline{\overline{x} y}. \encoding {ps} q \\
\encoding c { p_1 + p_2 }_x &= \encoding c {p_1}_x + \encoding c {p_2}_x  
\end{align*}
Then, for every pair of processes $q_1, q_2$ of Multi-$\pi^{+ps}$, $q_1 \sim q_2 \iff \encoding {ps} {q_1} \sim \encoding {ps} {q_2} $.
\end{proposition}

As for polyadic communication, the parameter $x$ of the function $\encoding {ps} \cdot _x$ is not used in the encoding of the 
input and silent action.


% \subsection{Petri nets}

\subsection{Last man standing problem}
The Last Man Standing (LMS) has been introduced in \cite{VBG09} as the first problem of distributed computing able to differentiate
``truly parallel'' languages from those whose underlying implementation requires, to some degree, centralization.
We can informally say that the LMS can be solved in some process calculus if there exist a process $p$ able to
detect the presence or absence of other processes without generating deadlocks or introducing divergence. In order to say that the LMS can be solved in Multi-$\pi$,
we would need to identify a process $p$ such that $p$ is able to perform an action $a$ only when there is exactly one copy of $p$ in the current system, while $p$ is able to perform an action $b$ only when there are at least two copies of $p$ in the current system. In other words, if $s_i$ is the system where $i$ copies of $p$ are enabled, we should have that
\begin{align*}
& &  s_1 &= p           & s_1 \deriv{a} s_1' & & \qquad s_1 \nderiv{b} s_1'' \\
\text{while} \hspace{1cm} \\
& & s_2 &= p \para p           & s_2 \nderiv{a} s_2' & & \qquad s_2 \deriv{b} s_2'' \\
& & \ldots \\
& & s_n &= \underbrace{p \para p \para \cdots \para p}_{n} & \qquad s_n \nderiv{a} s_n' & & \qquad s_n \deriv{b} s_n'' & \hspace{\textwidth}
\end{align*}
with $a \neq b$. 
Rule $(Par)$ in Table \ref{rules} allows us to easily prove that the LMS cannot be solved in Multi-$\pi$. In fact it
states that any process $p$, able to perform some action $a$,
can perform the same action in the presence of other processes as well, so that if $p \deriv{a} p'$, then also $p \para p \deriv{a} p \para p'$, which contradicts the requirement
that $s_2 \nderiv{a} s_2'$.




\section{Low-level semantics\\[-.6cm]}\label{multi-low}

In this section we want to offer an alternative semantics to the calculus where each transition is labeled by one single action,
but where the states are not all equally observable. In more detail, we define an enriched set of process terms, obtained by 
the introduction of an auxiliary state operator $\istar p$: if a process term is marked by $\istar$, then it represents an intermediate
state of the transaction and so cannot be observed. Marked processes are ranged over by $l$, possibly indexed.

We also define  a low-level transition relation $\tderiv{}$ which 
relates extended process terms. For instance, for process $p = \underline{\bar xy}.\bar zy.q$ we can derive the following:
$p \tderiv{\bar xy} *(\bar zy.q) \tderiv{\bar zy} q$, while in the abstract semantics of Section 3 we get $p \deriv{\bar xy \bar zy}  q$.

The labels of the low-level transition systems are enriched by the empty label $\epsilon$ that is needed to label
the transitions corresponding to, e.g., strongly prefixed $\tau$'s. For instance, $p'= \underline\tau.\bar zy.q$ is such that
$p' \tderiv{\epsilon} *(\bar zy.q) \tderiv{\bar zy} q$. We use $\gamma$ to range over the set of possible low-level labels.

Marked processes should have priority when composed with unmarked processes, to express that the transaction
is to be completed before any other activity can take place. When a process $p$ in $p \para q$ starts a transaction,
it may decide that also the sibling process $q$ should cooperate in the transaction; this is obtained by marking $q$.
For instance, if $p \tderiv{\gamma} l$, we can derive both $p \para q \tderiv{\gamma} l \para q$ and $p \para q \tderiv{\gamma} l \para *q$;
the former option represent the situation in which $p$ performs its transaction in isolation, the latter option, instead,
the case when also $q$ is invited to join. Of course, if $q$ is not willing to cooperate, the process $ l \para *q$ may be unable to
complete a transaction (by reaching an observable state). As only computations that start from and arrive to observable states
are considered relevant, these spurious additional low-level computations are inessential.



\begin{table}
\hrulefill\\[-.8cm]
{\renewcommand{\arraystretch}{2.6}
\begin{center}
$\begin{array}{lcllcl}
\mbox{(tau)}  & \tau.p\tderiv{\tau}p & &
\mbox{(in)}  & x(z).p\tderiv{xy}p\sost{y}{z} & y \notin fn(\restr{z}p)\\
\mbox{(s-tau)}  & \underline{\tau}.p \tderiv{\epsilon}\istar p & & 
\mbox{(s-in)}  & \underline{x(z)}.p\tderiv{xy}\istar p\sost{y}{z} & y \notin fn(\restr{z}p)\\
\mbox{(out)}  & \bar{x}y.p\tderiv{\bar{x}y}p & & \mbox{(s-out)}  & \underline{\bar{x}y}.p\tderiv{\bar{x}y} \istar p \\
\mbox{(star)} &  \bigfrac{s\tderiv{\gamma}s'}{\istar s\tderiv{\gamma}s'} & & 
\mbox{(sum$_1$)}  & \bigfrac{p\tderiv{\gamma}s}{p+q\tderiv{\gamma}s}  \\
\mbox{(sum$_2$)}  & \bigfrac{q\tderiv{\gamma}s}{p+q\tderiv{\gamma}s} &&
\mbox{(res)}  & \bigfrac{s\tderiv{\gamma}s'}{\restr{y}s\tderiv{\gamma}
\restr{y}s'} & y\not\in n(\gamma)\\
\mbox{(cong$_1$)} & \bigfrac{p \equiv p' \tderiv{\gamma}q' \equiv q}{p\tderiv{\gamma}q} & & 
\mbox{(cong$_2$)} & \bigfrac{p \tderiv{\gamma}l \;\; p \equiv q}{q\tderiv{\gamma}l} \\
\mbox{(cong$_3$)} & \bigfrac{l \tderiv{\gamma}p \;\; p \equiv q}{l\tderiv{\gamma}q} & &
\mbox{(rec)} & \bigfrac{p\sost{\recx p}{X}\tderiv{\gamma}s}{\recx p\tderiv{\gamma}s}  \\
%\end{array}$

%$\begin{array}{lcllcl}

\mbox{(com$_1$)}  & \bigfrac{p\tderiv{\beta}p' \spazio q\tderiv{\bar\beta}q'}{p \para q \tderiv{\tau} p'\para q'} & &
\mbox{(com$_2$)}  & \bigfrac{l_1 \tderiv{\beta}l_1' \spazio l_2 \tderiv{\bar\beta}s'}{l_1 \para l_2 \tderiv{\epsilon} l_1' \para s'}  \\
\mbox{(com$_3$)}  & \bigfrac{p\tderiv{\beta}l \spazio q\tderiv{\bar\beta}s}{p \para q \tderiv{\epsilon} l\para s} & &
\mbox{(com$_4$)}  & \bigfrac{l\tderiv{\beta}p \spazio l'\tderiv{\bar\beta}q}{l \para l' \tderiv{\tau} p\para q}  \\

\end{array}$

$\begin{array}{lcl}
\mbox{(par$_1$)}  & \bigfrac{s\tderiv{\gamma}s'}{s\para p\tderiv{\gamma}s'\para p} & bn(\gamma) \cap fn(p) = \emptyset  \\
\mbox{(par$_2$)}  & \bigfrac{p\tderiv{\gamma}l}{p\para q\tderiv{\gamma}l\para \istar q} & bn(\gamma) \cap fn(q) = \emptyset \\
\mbox{(par$_3$)}  & \bigfrac{l_1\tderiv{\gamma}l'}{l_1\para l_2\tderiv{\gamma}l'\para l_2} & bn(\gamma) \cap fn(l_2) = \emptyset  \\

\mbox{(open)}  & \bigfrac{s\tderiv{\bar{x}y}s'}{\restr{y}s\tderiv{\bar{x}(w)}
s'\sost{w}{y}} & y \neq x \;\; w \notin fn(\restr{y}s')
\end{array}$

\hrulefill
\end{center}}
\caption{SOS low level rules  -- symmetric rules of (com$_2$)-(com$_3$) and (par$_1$)-(par$_3$) omitted.}\label{low1}
\end{table}



In the rules in Table \ref{low1} we use the following convention: observable states are normal processes $p, q$, possibly indexed; 
unobservable states are marked processes $l$, possibly indexed, while states (observable or not observable) are ranged over by 
$s$, possibly indexed. We define the following derivation relation: 

$\begin{array}{lcl}
 \bigfrac{p\tderiv{\gamma_1}l_1 \tderiv{\gamma_2} l_2 \ldots l_{k-1} \tderiv{\gamma_k}p'}{p \derivas{\gamma_1 \ldots \gamma_k} p'} & k\geq 1\\
\end{array}$

The following proposition states the soundness and the completeness of the low-level semantics w.r.t. the abstract semantics.

\begin{proposition}
For any Multi-$\pi$ process $p$, $p \deriv{\sigma} p'$ if and only if $p \derivas{\sigma} p'$.

\proof 
The proof of the {\em only if} part is by induction on the proof of transition $p \deriv{\sigma} p'$. The proof of 
the {\em if} part is by induction on the length of the sequence of transitions used to derive $p \derivas{\sigma} p'$
and on the depth of the proof tree of the first transition in such a sequence.
\fine
\end{proposition}



\section{Conclusion}\label{multi-conc}
Multi-$\pi$ is a conservative extension to the $\pi$-calculus, with essentially the same algebraic properties,
but with a much richer modeling power, as the examples reported in this paper show. In particular, the 
polite dining philosophers problem and the mobile telephone example shows the interplay between
mobility and atomic sequences of synchronization. Moreover, the extensions of polyadic communication \cite{Mil91}
and polyadic synchronization \cite{CM03} are encoded in Multi-$\pi$ thanks to its transactional 
communication capability. 

\subsection{Related work}

%We shortly review the main related literature.

\subsubsection{Mobile Multi-party synchronization}
 
In the literature, there are only a few calculi for mobility offering multi-party synchronization  \cite{EM99,HYC08}. 

In particular,  \cite{EM99} presents the $b\pi$-calculus (where $b$ stands for {\em broadcast}) as  a variant of the 
$\pi$-calculus where the point-to-point synchronisation mechanism is replaced by broadcast communication: the
name $x$ sent along a channel name $a$ is received by all the processes ready to input on channel $a$.
The form of multi-party synchronization offered by Multi-$\pi$ is more flexible, as we do not need to use
a shared channel name $a$, rather it is implemented as an atomic sequence of standard binary synchronizations.
Moreover, $b\pi$ does not offer any form of atomic transactional communication and so Patil's problem
cannot be solved in  $b\pi$. On the other hand, in $b\pi$-calculus it is possible to solve the leader-election problem
for an arbitrary number of participants, while this problem is solvable in Multi-$\pi$ only for a fixed number of participants.

Paper \cite{HYC08} describes a calculus with asynchronous multi-party sessions, where a process can perform a suitable multicast
to some designated processes (that share the same channel name) and start a session by initializing some fresh session channels 
for the rest of the conversation. The main difference w.r.t. Multi-$\pi$ is that this calculus is based on sessions, that represent
a striking different abstraction of communication.

A recent interesting paper on a non-mobile calculus for multi-party synchronization is \cite{LV10}, where
it is showed that there is an expressiveness gap between a CCS-based calculus with at most $n$-ary synchronizations
and a CCS-based calculus with (at most) $n+1$-ary synchronizations 
by means of a generalization of the dining philosophers' problem.

\subsubsection{Atomic actions}

A$^2$CCS \cite{GMM} is an extension to CCS with the operator of strong prefixing. This calculus has been
refined in \cite{GV10} to Multi-CCS, by making associative its parallel composition operator and by changing its synchronization
relation $Sync$ over sequences.  

Paper \cite{ABD07} presents AtCCS, a CCS-like calculus with a more elaborated mechanism for atomic transactions, 
somehow inspired by the work on {\em Software Transactional Memories} (STM for short) \cite{HM93}. Transactions
are performed with an optimistic evaluation discipline. All actions are performed on a copy of the memory (the local state);
when the transactions ends, there are two possible outcomes: if some concurrent writes have occurred, the transaction 
aborts and is then rescheduled; otherwise, the transaction commits and its effect is propagated instantaneously.
In AtCCS it is possible to have multi-party communication as well.


\subsubsection{Long running transactions and compensation}

There is a large body of work on long running transctions for Web Services (see, e.g, \cite{BMM05,BBF+05,BHF04}, just
to mention a few), equipped with some compensations. As in this setting transactions can last for a long time, it is 
unreasonable to demand atomicity and isolation in the execution of a transaction. Therefore, in case of failure,
a compensation (a piece of code) is to be executed in order to undo most of the visible actions that have been
performed.


\subsection{Future work}

We plan to equip Multi-$\pi$ with
a distributed semantics in terms of nets with inhibitor arcs, in the style of \cite{BG09}. 
This net semantics offers a finite net representation for the so-called {\em finite-net} Multi-$\pi$ processes,
i.e., processes where restriction cannot occur inside recursion (but parallel composition can!)
and $Sync(\sigma_1, \sigma_2, \sigma)$ is defined if $\sigma_1$ or $\sigma_2$ is a single action (a limitation
that does not prevent multi-party synchronization). For instance, the system $Patil'$ of Section 4 is a typical example
of a finite-net process: its net semantics is a finite and safe P/T net, in contrast to the fact that its interleaving semantics
generates an infinite-state lts. According to \cite{GV10}, it can be proved that finite-net processes are expressive 
enough to represent all finite P/T nets, a further interesting expressiveness result for Multi-$\pi$. 

Future work will be also devoted to define a more elaborate low-level {\em reversible} semantics, in the style of  \cite{DK04} 
(in turn based on an idea in \cite{BPW94}), with the ability of backtracking when an unobservable deadlock is met.


%\begin{center}
%{\em Acknowledgements}
%\end{center}
%The authors would like to thank the anonymous
%referees for helpful comments.


\bibliographystyle{eptcs} % or whatever you prefer
\begin{thebibliography}{10}

\bibitem[ABD07]{ABD07}
L. Acciai, M. Boreale, S. Dal-Zilio,
\newblock ``A Concurrent Calculus with Atomic Transactions'', 
\newblock in Proc. ESOP'07, LNCS 4421: 48-63, 2007.

\bibitem[BPW94]{BPW94}
J. Bergstra, A. Ponse, J.J. van Walem,
\newblock  ``Process Algebra with Backtracking'',
\newblock in Proc. {\em REX School/Symposium}, LNCS 803:46-91, 1994.

\bibitem[BMM05]{BMM05}
R. Bruni, H.C. Melgratti, U. Montanari
\newblock ``Theoretical Foundations for Compensations in Flow Composition Languages'',  
\newblock in Procs. POPL'05, ACM Press, pp. 209-220, 2005.

\bibitem[BBF+05]{BBF+05}
R.  Bruni, M.J. Butler, C. Ferreira, C. A. R. Hoare, H. C. Melgratti, U. Montanari
\newblock ``Comparing Two Approaches to Compensable Flow Composition'',
\newblock in Procs. CONCUR'05, LNCS 3653: 383-397, 2005.

\bibitem[BHF04]{BHF04}
M. J. Butler, C. A. R. Hoare, C. Ferreira
\newblock ``A Trace Semantics for Long-Running Transactions'',
\newblock in {\em 25 Years Communicating Sequential Processes}, LNCS 3525: 133-150, 2004.

%\bibitem[BK84]{BK84}
%J.A.~Bergstra, J.W.~Klop,
%\newblock ``Process Algebra for Synchronous Communication'',
%\newblock {\em Information and Control} 60:109-137, 1984.

\bibitem[BG09]{BG09}
N.~Busi, R.~Gorrieri,
\newblock ``Distributed semantics for the $\pi$-calculus based on Petri nets with inhibitor arcs'',
\newblock {\em J. of Logic and Alg. Programming} 78(3):138-162, 2009.

\bibitem[CM03]{CM03}
M.  Carbone, S. Maffeis,
\newblock ``On the Expressive Power of Polyadic Synchronisation in pi-calculus'', 
\newblock {\em Nordic Journal of Computing} 10(2): 70-98, 2003.

\bibitem[Dij68]{Dij68}
E.W.Dijkstra, ``Cooperating sequential processes'', 
\newblock (F. Genuys ed.) {\em Programming Languages}, Academic Press, 43-112, 1968.

\bibitem[Dij71]{Dij71}
E.W.Dijkstra, ``Hierarchical ordering of sequential processes'', 
\newblock {\em Acta Informatica} 1(2):115-138, 1971.

\bibitem[DK04]{DK04}
V. Danos, J. Krivine,
\newblock  ``Reversible Communicating Systems'',
\newblock in Proc. CONCUR'04, LNCS 3170: 292-307, 2004.

\bibitem[EM99]{EM99}
C. Ene, T. Muntean,
\newblock  ``Expressiveness of point-to-point versus broadcast communications'',
\newblock In Procs. FCT'99, Springer-Verlag LNCS 1684:258-268, 1999.

\bibitem[HM93]{HM93}
M. Herlihy, J.E.B. Moss,
\newblock `Transactional Memory: Architectural Support for Lock-Free Data Structures'', 
\newblock in Procs. Int.l Symposium on Computer Architecture (ISCA'93),
IEEE-CS Press, pp. 289-300, 1993.

%\bibitem[Gor92]{Gor92}
%R. Gorrieri,
%``A Hierarchy of System Descriptions via Atomic Linear Refinement'',
% {\em Fundamenta Informaticae}, 16 (3/4):289-336, 1992.

\bibitem[GM90]{GM90} 
R. Gorrieri, U. Montanari, ``Towards Hierarchical Specification of Systems:
A Proof System for Strong Prefixing'',
{\em Int. Journal of Foundations of Computer Science},
1(3):277-293, 1990.

\bibitem[GMM90]{GMM}
R.~Gorrieri, S.~Marchetti, U.~Montanari,
\newblock ``A$^2$CCS: Atomic Actions for CCS'',
\newblock {\em Theoretical Computer Science} 72(2-3): 203-223, 1990.

\bibitem[GV10]{GV10}
R.~Gorrieri, C.~Versari,
\newblock ``A Process Calculus for expressing finite Place/Transition Petri Nets'',
\newblock Submitted, 2010.

%\bibitem[GMV10]{GMV10}
%R.~Gorrieri, R.~Meyer, C.~Versari,
%\newblock ``Petri Net Semantics for Multi-$\pi$'',
%\newblock In preparation, 2010.

\bibitem[HYC08]{HYC08}
Kohei Honda, Nobuko Yoshida, M. Carbone
\newblock  ``Multiparty asynchronous session types'', 
\newblock in Proc. POPL'08, ACM Press, pp. 273-284, 2008.

\bibitem[LR81]{LR81}
D.J. Lehmann. M.l O. Rabin.,
\newblock ``On the advantages of free choice: 
A symmetric and fully distributed solution to the dining philosophers problem'',
\newblock In Procs. POPL'81, pages 133-138,  ACM Press, 1981. 

\bibitem[LV10]{LV10}
C.~Laneve, A.~Vitale,
\newblock ``The Expressive Power of Synchronizations'',
\newblock to appear in procs LICS'10, 2010.

\bibitem[Mil89]{Mil89}
R.~Milner,
\newblock {\em {Communication and Concurrency}},
\newblock Prentice-Hall, 1989.

\bibitem[Mil91]{Mil91}
R.~Milner,
\newblock ``The Polyadic $\pi$--Calculus: A Tutorial'',
\newblock Technical Report, Dept. of Computer Science,
  University of Edinburgh, ECS--LFCS--91--180, Oct. 1991.

\bibitem[Mil99]{Mil99} R. Milner. {\it Communicating and mobile systems: the
$\pi$-calculus},
Cambridge University Press, 1999.

\bibitem[MPW92]{MPW}
R.~Milner, J.~Parrow, D.~Walker,
\newblock ``A Calculus of Mobile Processes'',
\newblock {\em Information and Computation} 100(1), 1-77, 1992.

\bibitem[NP96]{NP96}
U. Nestmann and B.C. Pierce.
\newblock Decoding Choice Encodings.
\newblock In {Proceedings of 7th International Conference on Concurrency Theory (CONCUR'96)},
Lecture Notes in Computer Science vol. 1119, Springer, Berlin, pp. 179-194, 1996.

\bibitem[Pat71]{Pat71}
S. Patil
\newblock ``Limitations and Capabilities of Dijkstra's Semaphore 
Primitives for Coordination Among Processes'',
\newblock Computation Structures Group Memo 57, Project MAC, MIT, 1971.

\bibitem[Pet81]{Pet81}
J.L. Peterson,
\newblock {\em Petri Net Theory and the Modeling of Systems}, Prentice-Hall, 1981.

\bibitem[SW01]{SW}
D. Sangiorgi, D. Walker,
\newblock {\em The $\pi$-calculus: A Theory of Mobile Processes},
\newblock Cambridge University Press, 2001.

\bibitem[VBG09]{VBG09}
C. Versari, N. Busi, R. Gorrieri.
\newblock An expressiveness study of priority in process calculi. 
\newblock {\em Mathematical Structures in Computer Science} 19(6): 1161-1189, 2009.


\end{thebibliography}



% \end{document}


\section*{Appendix A: operational rules for polyadic communication}


\begin{table}
\hrulefill\\[-.8cm]

\begin{align*}
& \mbox{(In)}    & &  x(\vect z).p\deriv{x \vect y}p\sost{\vect y}{\vect z} & & y_1, \ldots, y_n \notin fn(\restr{z_1}\ldots\restr{z_n}p) \\
& \mbox{(S-in)}  & & \bigfrac{p\sost{\vect y}{\vect z}\deriv{\sigma}p'}{\underline{x(\vect z)}.p\deriv{x \vect y\sigma}p'} & & y_1, \ldots, y_n \notin fn(\restr{z_1}\ldots\restr{z_n}p)\\ 
& \mbox{(Out)}  & & \bar{x} \vect y.p\deriv{\bar{x} \vect y}p \\
& \mbox{(S-out)} & & \bigfrac{p\deriv{\sigma}p'}{\underline{\bar{x} \vect y}.p\deriv{\bar{x} \vect y\sigma}p'} \\
& \mbox{(Open)} & & \quad \bigfrac{p\deriv{\sigma}p'}{\restr{y}p\deriv{\sigma'}
p'} & & \overline{x} \vect y \in \sigma, \quad y = y_i \text{ for some }i, \; \mbox{ and }  \; Res(\sigma, y)= \sigma'  
\end{align*}
\hrulefill
\caption{SOS extended rules for polyadic communication, with $\vect y = y_1 \ldots y_n, \vect z = z_1 \ldots z_n$ for some $n$. }\label{pcrules}
\end{table}

\begin{table}
\hrulefill\\[-.7cm]
{\renewcommand{\arraystretch}{3}}

\begin{align*}
Res(\epsilon, y) & = \epsilon \\
Res(x \vect y \sigma, y_i) & = \undef  & & \vect y = y_1 \ldots y_n, \quad 1 \leq i \leq n \\
%
Res(y \vect x \sigma, y) & = \undef & & \vect x = x_1 \ldots x_n \\
Res(z \vect w \sigma, y)   & = z \vect w Res(\sigma, y) & & \vect w = w_1 \ldots w_n \\
%
Res(\overline{z} \vect y \sigma, y_i) & = \overline{z} \vect y' \sigma & & \vect y = y_1 \ldots y_n, \quad y' = y_1 \ldots (y_i) \ldots y_n\\
Res(\overline{z} \vect w \sigma, y) & = \overline{z} \vect w  Res(\sigma, y) & & \vect w = w_1 \ldots w_n \\
Res(\overline{y} \vect x \sigma, y) & = \undef & & \vect x = x_1 \ldots x_n \\[-.7cm]
\end{align*}

\hrulefill
\caption{Restriction relation extended for polyadic communication -- $z, z_i$ and $w, w_i$ are assumed different of $y, y_i$.}\label{pcrestr}
\end{table}


In Table \ref{pcrules} and \ref{pcrestr} the SOS rules of Multi-$\pi$ are extended for polyadic communication. The synchronization relation of Table \ref{sync} is basically unchanged, with proper extension of $\beta, \overline{\beta}$ to the polyadic %communication 
setting.



\begin{table}
\hrulefill\\[-.8cm]

\begin{align*}
& \mbox{(In)}    & &  \vect x(z).p\deriv{\vect xy}p\sost{y}{z} & &  y \notin fn(\restr{z}p) \\
& \mbox{(S-in)}  & & \bigfrac{p\sost{y}{z}\deriv{\sigma}p'}{\underline{\vect x(z)}.p\deriv{\vect xy\sigma}p'} & & y \notin fn(\restr{z}p)\\
& \mbox{(Out)}  & & \bar{\vect x}y.p\deriv{\bar{\vect x}y}p \\
& \mbox{(S-out)} & & \bigfrac{p\deriv{\sigma}p'}{\underline{\bar{\vect x}y}.p\deriv{\bar{\vect x}y\sigma}p'} \\
& \mbox{(Open)} & & \quad \bigfrac{p\deriv{\sigma}p'}{\restr{y}p\deriv{\sigma'}
p'} & &  \overline{\vect x} \langle y \rangle \in \sigma, \;  \mbox{ and }  \; Res(\sigma, y)= \sigma'  
\end{align*}
\hrulefill
\caption{SOS extended rules for polyadic synchronization, with $\vect x = x_1@\ldots@x_n$.}\label{psrules}
\end{table}

\section*{Appendix B: operational rules for polyadic synchronization}


\begin{table}
\hrulefill\\[-.7cm]
{\renewcommand{\arraystretch}{3}}

\begin{align*}
Res(\epsilon, y) & = \epsilon \\
Res(\vect x y \sigma, y) & = \undef & & \vect x = x_1@\ldots@x_n \\
%
Res(\vect y x \sigma, y_i) & = \undef & & \vect y = y_1@\ldots@y_n \quad 1 \leq i \leq n \\
Res(\vect z w \sigma, y)   & = \vect z w  Res(\sigma, y) & & \vect z = z_1@\ldots@z_n \\
%
Res(\overline{\vect z } y \sigma, y) & = \overline{\vect z} ( y ) \sigma  & & \vect z = z_1@\ldots@z_n \\
Res(\overline{\vect z} w  \sigma, y) & = \overline{\vect z} w Res(\sigma, y)  & & \vect z = z_1@\ldots@z_n \\
Res(\overline{\vect y} x \sigma, y_i) & = \undef  & & \vect y = y_1@\ldots@y_n \quad 1 \leq i \leq n \\[-.7cm]
\end{align*}

\hrulefill
\caption{Restriction relation extended for polyadic synchronization -- $z, z_i$ and $w$ are assumed different of $y, y_i$.}\label{psrestr}
\end{table}


In Table \ref{psrules} and \ref{psrestr} the SOS rules of Multi-$\pi$ are extended for polyadic synchronization. As for polyadic communication, the synchronization relation of Table \ref{sync} is basically unchanged, with proper extension of $\beta, \overline{\beta}$ to the polyadic synchronization setting.


\end{document}