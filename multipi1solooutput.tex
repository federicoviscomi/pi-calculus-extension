
\section{Syntax}
As we did whit $\pi$ calculus, we suppose that we have a countable set of names $\mathbb{N}$, ranged over by lower case letters $a,b, \cdots, z$. This names are used for communication channels and values. Furthermore we have a set of identifiers, ranged over by $A$. We represent the agents or processes by upper case letters $P,Q, \cdots $. A multi $\pi$ process, in addiction to the same actions of a $\pi$ process, can perform also a strong prefix output:
\begin{center}
  $\pi$ ::= $\overline{x}y$ | $x(z)$ | $\underline{\overline{x}y}$ | $\tau$ 
\end{center}
The process are defined, just as original $\pi$ calculus, by the following grammar:
\begin{center}
  \begin{tabular}{l}
    $P,Q$ ::= $0$ | $\pi.P$ | $P|Q$ | $P+Q$ | $(\nu x) P$ | $A(y_{1}, \cdots, y_{n})$
  \end{tabular}
\end{center}
and they have the same intuitive meaning as for the $\pi$ calculus. The strong prefix output allows a process to make an atomic sequence of actions, so that more than one process can synchronize on this sequence. For the moment we allow the strong prefix to be on output names only. Also one can use the strong prefix only as an action prefixing for processes that can make at least a further action. Since the strong prefix can be on output names only, the only synchronization possible is between a process that executes a sequence of $n$ actions(only the last action can be an input) with $n\geq 1$ and $n$ other processes each executing one single action(at least $n-1$ process execute an output and at most one executes an input).

Multi $\pi$ calculus is a conservative extension of the $\pi$ calculus in the sense that: any $\pi$ calculus process $p$ is also a multi $\pi$ calculus process and the semantic of $p$ according to the SOS rules of $\pi$ calculus is the same as the semantic of $p$ according to the SOS rules of multi $\pi$ calculus. 

We have to extend the following definition to deal with the strong prefix:
\begin{center}
  \begin{tabular}{ll}
	$B(\underline{\overline{x}y}.Q, I)\; =\; B(Q,I)$
      &
	$F(\underline{\overline{x}y}.Q, I)\; =\; \{x,\overline{x},y,\overline{y}\}\cup F(Q, I)$
    \\
  \end{tabular}
\end{center}


\section{Operational semantic}
\subsection{Early operational semantic with structural congruence}

The semantic of a multi $\pi$ process is labeled transition system such that
\begin{itemize}
  \item 
    the nodes are multi $\pi$ calculus process. The set of node is $\mathbb{P}_{m}$
  \item
    the actions are multi $\pi$ calculus actions. The set of actions is $\mathbb{A}_{m}$, we use $\alpha, \alpha_{1}, \alpha_{2},\cdots $ to range over the set of actions, we use $\sigma, \sigma_{1}, \sigma_{2}, \cdots $ to range over the set $\mathbb{A}_{m}^{+} \cup \{\tau\}$. Note that $\sigma$ is a non empty sequence of actions.
  \item
    the transition relations is $\rightarrow\subseteq \mathbb{P}_{m}\times (\mathbb{A}_{m}^{+} \cup \{\tau\})\times \mathbb{P}_{m}$
\end{itemize}

In this case, a label can be a sequence of prefixes, whether in the original $\pi$ calculus a label can be only a prefix. We use the symbol $\cdot$ to denote the concatenation operator.

\begin{definition}\index{transition relation! multipi! output only! early! with structural congruence}
  The \emph{early transition relation without structural congruence} is the smallest relation induced by the rules in table \ref{multipiearlywith}. The relation $opn$ is defined in table \ref{opn}.
  \begin{table}
    \begin{tabular}{ll}
      \hline\\
	  $\inferrule* [left=\bf{Out}]{
	  }{
	    \overline{x}y.P \;\xrightarrow{\overline{x}y} P
	  }$
	&
	  $\inferrule* [left=\bf{EInp}]{
	  }{
	    x(y).P \;\xrightarrow{xz} P\{z/y\}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Tau}]{
	  }{
	    \tau.P \;\xrightarrow{\tau} P
	  }$
	&
	  $\inferrule* [left=\bf{SOut}]{
	    P \;\xrightarrow{\sigma} P^{'}\;\; \sigma\neq \tau
	  }{
	    \underline{\overline{x}y}.P \;\xrightarrow{\overline{x}y \cdot \sigma} P^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Sum}]{
	    P \;\xrightarrow{\sigma} P^{'}
	  }{
	    P+Q \;\xrightarrow{\sigma} P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{Str}]{
	      P\equiv P^{'}
	    \\
	      P^{'}\; \;\xrightarrow{\alpha}\; Q^{'}
	    \\
	      Q\equiv Q^{'}
	  }{
	      P\; \;\xrightarrow{\alpha}\; Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{Par}]{
	    P \;\xrightarrow{\sigma} P^{'}\;\; bn(\sigma)\cap fn(Q)=\emptyset
	  }{
	    P|Q \;\xrightarrow{\sigma} P^{'}|Q
	  }$
	&
	  $\inferrule* [left=\bf{EComSng}]{
	      P\; \xrightarrow{xy}\; P^{'}
	    \\
	      Q\; \xrightarrow{\overline{x}y}\; Q^{'}
	  }{
	    P|Q\; \xrightarrow{\tau}\; P^{'}|Q^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Res}]{
	    P\; \xrightarrow{\sigma} P^{'}\; z\notin n(\alpha)
	  }{
	    (\nu) z P\; \xrightarrow{\sigma}\; (\nu) z P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{EComSeq}]{
	      P \;\xrightarrow{xy}\; P^{'}
	    \\
	      Q\;\xrightarrow{\overline{x}y\cdot \sigma}\; Q^{'}
	  }{
	    P|Q\; \xrightarrow{\sigma}\; P^{'}|Q^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{SOutTau}]{
	    P \;\xrightarrow{\tau} P^{'}
	  }{
	    \underline{\overline{x}y}.P \;\xrightarrow{\overline{x}y} P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{OpnSeq}]{
	      P \xrightarrow{\sigma}\; P^{'}
	    \\ 
	      \exists \overline{x}z\in \sigma:\; x\neq z
	  }{
	      (\nu z)P \xrightarrow{opn(\sigma,z)}\; P^{'}
	  }$
      \\\\\hline
    \end{tabular}
    \caption{Multi $\pi$ early semantic with structural congruence}
    \label{multipiearlywith}
  \end{table}


  \begin{table}
    \begin{tabular}{lll}
      \hline\\
	  $\inferrule* {
	      x\neq z
	  }{
	      opn(\overline{x}z,z)=\overline{x}(z)
	  }$
	&
	  $\inferrule* {
	      x\neq z
	  }{
	      opn(\overline{x}z\cdot \sigma,z)=\overline{x}(z)\cdot opn(\sigma,z)
	  }$
	&
	  $\inferrule* {
	  }{
	      opn(xy,z)=xy
	  }$
      \\\\
	  $\inferrule* {
	  }{
	      opn(\overline{x}y,z)=\overline{x}y
	  }$
	&
	  $\inferrule* {
	  }{
	      opn(\overline{x}y\cdot \sigma,z)=\overline{x}y\cdot opn(\sigma,z)
	  }$
	&
      \\\\\hline
    \end{tabular}
    \caption{relation $opn$}
    \label{opn}
  \end{table}


\end{definition}




\begin{example}[Multi-party synchronization]
  We show an example of a derivation of three processes that synchronize.
\begin{center}
$\inferrule* [left=\bf{Res}]{
    x\notin n(\tau)
   \\
    \inferrule* [left=\bf{EComSeq}]{
	  \underline{\overline{x}y}.\overline{x}y.0|x(y).0
	    \xrightarrow{\overline{x}y}
	      0|0
      \\
	\inferrule* [left=\bf{Inp}]{
	}{
	  x(y).0	
	    \xrightarrow{xy} 
	      0
	}
    }{
      ((\underline{\overline{x}y}.\overline{x}y.0|x(y).0)|x(y).0)
	\xrightarrow{\tau}
	  ((0|0)|0)
    }
  }{
    (\nu x)((\underline{\overline{x}y}.\overline{x}y.0|x(y).0)|x(y).0)
      \xrightarrow{\tau}
	(\nu x)((0|0)|0)
}$
\end{center}

\begin{center}
$\inferrule* [left=\bf{EComSng}]{
  \inferrule* [left=\bf{SOut}]{
    \inferrule* [left=\bf{Out}]{
    }{
      \overline{x}y.0
	\xrightarrow{\overline{x}y}
	  0
    }
  }{
    \underline{\overline{x}y}.\overline{x}y.0
      \xrightarrow{\overline{x}y\cdot \overline{x}y}
	0
  }
  \\
    x(y).0\; \;\xrightarrow{xy}\; 0
}{
  \underline{\overline{x}y}.\overline{x}y.0|x(y).0
    \xrightarrow{\overline{x}y}
      0|0
}$
\end{center}

\end{example}

\begin{example}[Transactional synchronization]
  In this setting two process cannot synchronize on a sequence of actions with length greater than one. This is because of the rules $EComSng$ and $EComSeq$.
\end{example}



% \begin{example}
%   We want to prove that 
%   \[
%     (\underline{\overline{a}x}.c(x).0|b(x).0)|(a(x).0|\underline{\overline{b}x}.\overline{c}x.0)\;
%       \;\xrightarrow{\tau}\; 
% 	(0|0)|(0|0)
%   \]
% 
% 
% 
%   \begin{description}
%     \item[Str]
%       $(\underline{\overline{a}x}.c(x).0|b(x).0)|(a(x).0|\underline{\overline{b}x}.\overline{c}x.0)\;
% 	\;\xrightarrow{\tau}\; 
% 	  (0|0)|(0|0)$
%       \begin{description}
% 	\item[EComSng] 
% 	  $(\underline{\overline{a}x}.c(x).0|a(x).0)|(b(x).0|\underline{\overline{b}x}.\overline{c}x.0)\;
% 	    \;\xrightarrow{\tau}\;
% 	      (0|0)|(0|0)$
% 	  \begin{description}
% 	    \item[EComSeq]
% 	      $b(x).0|\underline{\overline{b}x}.\overline{c}x.0\;
% 		\;\xrightarrow{\overline{c}x}\;
% 		  0|0$
% 	      \begin{description}
% 		\item[EInp]
% 		  $b(x).0
% 		    \;\xrightarrow{bx}\;
% 		      0$
% 		\item[SOut]
% 		  $\underline{\overline{b}x}.\overline{c}x.0\;
% 		    \;\xrightarrow{\overline{b}x\cdot \overline{c}x}\;
% 		      0$
% 		  \begin{description}
% 		    \item[Out]
% 		      $\overline{c}x.0\;
% 			\;\xrightarrow{\overline{c}x}\;
% 			  0$
% 		  \end{description}
% 	      \end{description}
% 	    \item[EComSeq]
% 	      $\underline{\overline{a}x}.c(x).0|a(x).0\;
% 		\;\xrightarrow{cx}\;
% 		  0|0$
% 	      \begin{description}
% 		\item[SOut]
% 		  $\underline{\overline{a}x}.c(x).0\;
% 		    \;\xrightarrow{\overline{a}x\cdot cx}\;
% 		      0$
% 		  \begin{description}
% 		    \item[Inp]
% 		      $c(x).0\;
% 			\;\xrightarrow{cx}\;
% 			  0$
% 		  \end{description}
% 		\item[Inp]
% 		  $a(x).0\;
% 		    \;\xrightarrow{ax}\;
% 		      0$
% 	      \end{description}
% 	  \end{description}
% 	\item[]
% 	  $(\underline{\overline{a}x}.c(x).0|b(x).0)|(a(x).0|\underline{\overline{b}x}.\overline{c}x.0)\;
% 	    \equiv\;
% 	      (\underline{\overline{a}x}.c(x).0|a(x).0)|(b(x).0|\underline{\overline{b}x}.\overline{c}x.0)$
%       \end{description}
%   \end{description}
% \end{example}


% \begin{example}
%   The \emph{dining philosophers} problem, originally proposed by Dijkstra in \cite{djkstra}, is defined in the following way: Five silent philosophers sit at a round table. There is one fork between each pair of adjacent philosophers. Each philosopher must alternately think and eat. However, a philosopher can only eat while holding both the fork to the left and the fork to the right. Each philosopher can pick up an adjacent fork, when available, and put it down, when holding it. The problem is to design an algorithm such that no philosopher will starve, i.e. can forever continue to alternate between eating and thinking. We present one solution which uses only two forks and two philosophers:
%   \begin{itemize}
%     \item
%       we define two constants for the forks:
%       \begin{center}
% 	\begin{tabular}{ll}
% 	    $fork_{1}\; \stackrel{def}{=}\; up_{1}(x).dn_{1}(x).fork_{1}$
% 	  &
% 	    $fork_{0}\; \stackrel{def}{=}\; up_{0}(x).dn_{0}(x).fork_{0}$
% 	\end{tabular}
%       \end{center}
%       the input name $x$ is not important and can be anything else.
%     \item
%       we define two constants for the philosophers:
%       \begin{center}
% 	\begin{tabular}{l}
% 	    $phil_{1}\; \stackrel{def}{=}\; think(x).phil_{1}+\underline{\overline{up_{1}}x}.\overline{up_{0}}(x).eat(x).\underline{\overline{dn_{1}}x}.dn_{0}(x).phil_{1}$
% 	  \\
% 	    $phil_{0}\; \stackrel{def}{=}\; think(x).phil_{0}+\underline{\overline{up_{0}}x}.\overline{up_{1}}(x).eat(x).\underline{\overline{dn_{0}}x}.dn_{1}(x).phil_{0}$
% 	\end{tabular}
%       \end{center}
%       also in this case the name $x$ is not relevant.
%     \item
%       the following definition describe the whole system with philosophers and forks:
%       \begin{center}
% 	$DP\; \stackrel{def}{=}\; (\nu \{up_{0}, up_{1}, down_{0}, down_{1}\})(phil_{0}|phil_{1}|fork_{0}|fork_{1})$
%       \end{center}
%       where with $(\nu \{up_{0}, up_{1}, down_{0}, down_{1}\})$ we mean $(\nu\; up_{0}) (\nu\; up_{1}) (\nu\; down_{0}) (\nu\; down_{1})$
%     \item
%       the operational semantic of $DP$ is the following lts:
%       \begin{center}
% 	\begin{tikzpicture}[%
% 	    ->,
% 	    >=stealth,
% 	    shorten >=1pt,
% 	    node distance=2.8cm,
% 	    %on grid,
% 	    auto,
% 	    state/.append style={minimum size=2em},
% 	    thick
% 	  ]
% 
% 
%   %\tikzstyle{every state}=[fill=red,draw=none,text=white]
% 
% 
% 	  \node[state] (A) {$P_{1}eaten$};
% 	  \node[state] (B) [below right of=A] {$P_{1}F_{0,1}$};
% 	  \node[state] (DP)[above right of=B] {$DP$};
% 	  \node[state] (C) [below right of=DP] {$P_{0}F_{0,1}$};
% 	  \node[state] (D) [above right of=C] {$P_{0}eaten$};
%   
% 	  \path[->] 
% 	      
%               (DP)       edge [loop above] node {$think\;x$} (DP)
% 			 edge              node {$\tau$} (C)
% 			 edge              node {$\tau$} (B)
% 	      (A)        edge [loop above] node {$think\;x$} (A)
% 			 edge              node {$\tau$} (DP)
% 	      (B)        edge [loop below] node {$think\;x$} (B)
% 			 edge   	   node {$eat\;x$} (A)
% 	      (C)        edge [loop below] node {$think\;x$} (C)
% 			 edge              node {$eat\;x$} (D)
% 	      (D)        edge [loop above] node {$think\;x$} (D)
% 			 edge              node {$\tau$} (DP);
%          
%       \end{tikzpicture}
%     \end{center}
%   \end{itemize}
%   Now we need to prove every transition in the semantic of $DP$. Let $L=\{up_{0}, up_{1}, down_{0}, down_{1}\}$ we start with $DP\xrightarrow{\tau}DP$:
% 
% 
% 
% \end{example}

% \begin{example}
%   We want to show now an example of synchronization between four processes:
%   \begin{description}
%     \item[Res]
%       $(\nu\; a)((((\underline{\overline{a}x}.\underline{\overline{a}x}.\overline{a}x.0| a(x).0)| a(x).0)| a(x).0)\;
% 	\xrightarrow{\tau}\;
% 	  (\nu\; a)(((0|0)|0)|0))$
%       \begin{description}
% 	\item
% 	  $a\notin n(\tau)$
% 	\item[EComSng]
% 	  $(((\underline{\overline{a}x}.\underline{\overline{a}x}.\overline{a}x.0| a(x).0)| a(x).0)| a(x).0)\;
% 	    \xrightarrow{\tau}\;
% 	      ((0|0)|0)|0)$
% 	  \begin{description}
% 	    \item[EComSeq]
% 	      $(\underline{\overline{a}x}.\underline{\overline{a}x}.\overline{a}x.0| a(x).0)| a(x).0\;
% 		\xrightarrow{\overline{a}x}\;
% 		  (0|0)|0$
% 	      \begin{description}
% 		\item[EComSeq]
% 		  $\underline{\overline{a}x}.\underline{\overline{a}x}.\overline{a}x.0| a(x).0)\;
% 		    \xrightarrow{\overline{a}x\cdot \overline{a}x}\;
% 		      0|0$
% 		  \begin{description}
% 		    \item[SOut]
% 		      $\underline{\overline{a}x}.\underline{\overline{a}x}.\overline{a}x.0\;
% 			\xrightarrow{\overline{a}x\cdot \overline{a}x\cdot\overline{a}x}\;
% 			  0$
% 		      \begin{description}
% 			\item[SOut]
% 			  $\underline{\overline{a}x}.\overline{a}x.0\;\;\xrightarrow{\overline{a}x\cdot\overline{a}x}\;0$\newline
%  			  %\begin{description}
%  			  %   \item[SOut]
%  				$\;\;\;\; {\bf SOut}\; \underline{\overline{a}x}.\overline{a}x.0\;\;\xrightarrow{\overline{a}x\cdot\overline{a}x}\;0$\newline
% 	     			%\begin{description}
% 				%   \item[SOut]
% 				      .\hspace{4 mm}${\bf Out}\; \overline{a}x.0\;\;\xrightarrow{\overline{a}x}\;0$
% 				%\end{description}
%  			  %\end{description}
% 		      \end{description}
% 		    \item[Inp]
% 		      $a(x).0\;\;\xrightarrow{ax}\;0$
% 		  \end{description}
% 		\item[Inp]
% 		  $a(x).0\;\;\xrightarrow{ax}\;0$	 
% 	      \end{description}
% 	    \item[Inp]
% 	      $a(x).0\;\;\xrightarrow{ax}\;0$	      
% 	  \end{description}
%     \end{description}
%   \end{description}
% 
% \end{example}


% \begin{center}
% $\inferrule* [left=\bf{EComSeq}]{
%       \underline{\overline{x}y}.\overline{x}y.0
% 	\xrightarrow{\overline{x}y \cdot \overline{x}y}
% 	  0
%     \\
%     \inferrule* [left=\bf{EComSeq}]{
% 	  \underline{\overline{x}y}.\overline{x}y.0|x(y).0
% 	    \xrightarrow{\overline{x}y}
% 	      0|0
%       \\
% 	\inferrule* [left=\bf{Inp}]{
% 	}{
% 	  x(y).0	
% 	    \xrightarrow{xy} 
% 	      0
% 	}
%     }{
%       ((\underline{\overline{x}y}.\overline{x}y.0|x(y).0)|x(y).0)
% 	\xrightarrow{\tau}
% 	  ((0|0)|0)
%     }
%   }{
%     \underline{\overline{x}y}.\overline{x}y.0 | x(y).x(y).0
%       \xrightarrow{\tau}
% 	0|0
% }$
% \end{center}
% 
% \begin{center}
% $\inferrule* [left=\bf{EComSng}]{
%   \inferrule* [left=\bf{SOut}]{
%     \inferrule* [left=\bf{Out}]{
%     }{
%       \overline{x}y.0
% 	\xrightarrow{\overline{x}y}
% 	  0
%     }
%   }{
%     \underline{\overline{x}y}.\overline{x}y.0
%       \xrightarrow{\overline{x}y\cdot \overline{x}y}
% 	0
%   }
%   \\
%     x(y).0\; \;\xrightarrow{xy}\; 0
% }{
%   \underline{\overline{x}y}.\overline{x}y.0|x(y).0
%     \xrightarrow{\overline{x}y}
%       0|0
% }$
% \end{center}






\subsection{Late operational semantic with structural congruence}
% Definisci le regole late per Multi-pi. In questo caso credo sia indispensabile la restrizione sintattica che ti suggerivo(solo input nello strong prefixing e sincronizzazione solo con la prima), mentre mi pare che nel caso early dovrebbe funzionare anche il caso generale con Sync. 


\begin{definition}\index{transition relation! multipi! output only! late! with structural congruence}
  The \emph{late transition relation with structural congruence} is the smallest relation induced by the rules in table \ref{multipilatewith}.
  \begin{table}
    \begin{tabular}{ll}
	  \hline\\
	    $\inferrule* [left=\bf{Pref}]{
	    \alpha\; not\; a\; strong\; prefix
	  }{
	    \alpha.P \;\xrightarrow{\alpha} P
	  }$
	&
	  $\inferrule* [left=\bf{Par}]{
	      P\; \xrightarrow{\sigma} P^{'}
	    \\
	      bn(\sigma)\cap fn(Q)=\emptyset	  
	  }{
	    P|Q\; \xrightarrow{\sigma}\; P^{'}|Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{SOut}]{
	      P \;\xrightarrow{\sigma} P^{'}
	    \\
	      \sigma\neq \tau
	  }{
	      \underline{\overline{x}y}.P \;\xrightarrow{\overline{x}y \cdot \sigma} P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{LComSeq}]{
	      P \;\xrightarrow{xy} P^{'}
	    \\
	      Q\;\xrightarrow{\overline{x}z\cdot \sigma} Q^{'}
	    \\
	      z\notin fn(P)
	  }{
	    P|Q \;\xrightarrow{\sigma} P^{'}\{z/y\}|Q^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Sum}]{
	    P \;\xrightarrow{\sigma} P^{'}
	  }{
	    P+Q \;\xrightarrow{\sigma} P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{Str}]{
	      P\equiv P^{'}
	    \\
	      P^{'}\; \;\xrightarrow{\alpha}\; Q^{'}
	    \\
	      Q\equiv Q^{'}
	  }{
	      P\; \;\xrightarrow{\alpha}\; Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{Res}]{
	    P \;\xrightarrow{\sigma} P^{'}\;\; z\notin n(\alpha)
	  }{
	    (\nu) z P \;\xrightarrow{\sigma} (\nu) z P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{LComSng}]{
	      P \;\xrightarrow{xy} P^{'}
	    \\
	      Q\;\xrightarrow{\overline{x}z} Q^{'}
	    \\
	      z\notin fn(P)
	  }{
	    P|Q \;\xrightarrow{\tau} P^{'}\{z/y\}|Q^{'}
	  }$
      \\\hline
    \end{tabular}
    \caption{Multi$\pi$ late semantic with structural congruence}
    \label{multipilatewith}
  \end{table}
\end{definition}

\begin{example}[Multi-party synchronization]
  We show an example of a derivation of three processes that synchronize in the late semantic.
\begin{center}
$\inferrule* [left=\bf{Res}]{
    x\notin n(\tau)
   \\
    \inferrule* [left=\bf{LComSeq}]{
	  \underline{\overline{x}y}.\overline{x}y.0|x(y).0
	    \xrightarrow{\overline{x}y}
	      0|0
      \\
	\inferrule* [left=\bf{Pref}]{
	}{
	  x(y).0	
	    \xrightarrow{x(y)} 
	      0
	}
    }{
      ((\underline{\overline{x}y}.\overline{x}y.0|x(y).0)|x(y).0)
	\xrightarrow{\tau}
	  ((0|0)|0)
    }
  }{
    (\nu x)((\underline{\overline{x}y}.\overline{x}y.0|x(y).0)|x(y).0)
      \xrightarrow{\tau}
	(\nu x)((0|0)|0)
}$
\end{center}

\begin{center}
$\inferrule* [left=\bf{LComSng}]{
  \inferrule* [left=\bf{SOut}]{
    \inferrule* [left=\bf{Pref}]{
    }{
      \overline{x}y.0
	\xrightarrow{\overline{x}y}
	  0
    }
  }{
    \underline{\overline{x}y}.\overline{x}y.0
      \xrightarrow{\overline{x}y\cdot \overline{x}y}
	0
  }
  \\
    \inferrule* [left=\bf{Pref}]{
    }{
      x(y).0\; \;\xrightarrow{x(y)}\; 0
    }
}{
  \underline{\overline{x}y}.\overline{x}y.0|x(y).0
    \xrightarrow{\overline{x}y}
      0|0
}$
\end{center}

\end{example}

















\subsection{Low level semantic}
This section contains the definition of an alternative semantic for multi $\pi$. First we define a low level version of the multi $\pi$ calculus(here with strong prefixing on output only), we call this language low multi $\pi$. The low multi $\pi$ is the multi $\pi$ enriched with a marked or intermediate process $*P$:
\begin{center}
   \begin{tabular}{l}
     $P,Q$ ::= $0$ | $\pi.P$ | $P|Q$ | $P+Q$ | $(\nu x) P$ | $A(x_{1}, \cdots, x_{n})$ | $*P$
   \\\\
     $\pi$ ::= $\overline{x}y$ | $x(y)$ | $\underline{\overline{x}(y)}$ | $\tau$ 
   \end{tabular}
\end{center}
\begin{definition}
  The low level transition relation is the smallest relation induced by the rules in table \ref{lowleveltransitionrelation} in which $P$ stands for a process without mark, $L$ stands for a process with mark and $S$ can stand for both. 
  \begin{table}
    \begin{tabular}{ll}
      \hline\\
	  $\inferrule* [left=\bf{Out}]{
	  }{
	    \overline{x}y.P \stackrel{\overline{x}y}{\longmapsto} P
	  }$
	  &
	  $\inferrule* [left=\bf{EInp}]{
	  }{
	    x(y).P \stackrel{xz}{\longmapsto} P\{z/y\}
	  }$
      \\\\
	  $\inferrule* [left=\bf{SOutLow}]{
	  }{
	    \underline{\overline{x}y}.P \stackrel{xy}{\longmapsto} * P
	  }$
	  &
	  $\inferrule* [left=\bf{Tau}]{
	  }{
	    \tau.P \stackrel{\tau}{\longmapsto} P
	  }$
      \\\\
	  $\inferrule* [left=\bf{Sum}]{
	    P \stackrel{\gamma}{\longmapsto} S
	  }{
	    P+Q \stackrel{\gamma}{\longmapsto} S
	  }$
	  &
	  $\inferrule* [left=\bf{Star}]{
	      S \stackrel{\gamma}{\longmapsto} S^{'}
	  }{
	      *S \stackrel{\gamma}{\longmapsto} S^{'}
	  }$
      \\\\\\
	  $\inferrule* [left=\bf{Com1}]{
	      P \stackrel{\overline{x}y}{\longmapsto} P^{'}
	    \\
	      Q \stackrel{xy}{\longmapsto} Q^{'}
	  }{
	    P|Q \stackrel{\tau}{\longmapsto} P^{'}|Q^{'}
	  }$
	&
      \\\\
	  $\inferrule* [left=\bf{Com2L}]{
	      L_{1} \stackrel{xy}{\longmapsto} L_{1}^{'}
	    \\
	      L_{2} \stackrel{\overline{x}y}{\longmapsto} S
	  }{
	    L_{1}|L_{2} \stackrel{\epsilon}{\longmapsto} L_{1}^{'}|S
	  }$
	&
	  $\inferrule* [left=\bf{Com2R}]{
	      L_{1} \stackrel{\overline{x}y}{\longmapsto} L_{1}^{'}
	    \\
	      L_{2} \stackrel{xy}{\longmapsto} S
	  }{
	    L_{1}|L_{2} \stackrel{\epsilon}{\longmapsto} L_{1}^{'}|S
	  }$
      \\\\
	  $\inferrule* [left=\bf{Com3L}]{
	      P \stackrel{xy}{\longmapsto} L
	    \\
	      Q \stackrel{\overline{x}y}{\longmapsto} S
	  }{
	    P|Q \stackrel{\epsilon}{\longmapsto} L|S
	  }$
	&
	  $\inferrule* [left=\bf{Com3R}]{
	      P \stackrel{\overline{x}y}{\longmapsto} L
	    \\
	      Q \stackrel{xy}{\longmapsto} S
	  }{
	    P|Q \stackrel{\epsilon}{\longmapsto} L|S
	  }$
      \\\\
	  $\inferrule* [left=\bf{Com4L}]{
	      L_{1} \stackrel{\overline{x}y}{\longmapsto} P
	    \\
	      L_{2} \stackrel{xy}{\longmapsto} Q
	  }{
	    L_{1}|L_{2} \stackrel{\tau}{\longmapsto} P|Q
	  }$
	&
	  $\inferrule* [left=\bf{Com4L}]{
	      L_{1} \stackrel{xy}{\longmapsto} P
	    \\
	      L_{2} \stackrel{\overline{x}y}{\longmapsto} Q
	  }{
	    L_{1}|L_{2} \stackrel{\tau}{\longmapsto} P|Q
	  }$
      \\\\\\
	  $\inferrule* [left=\bf{Res}]{
	      S \stackrel{\gamma}{\longmapsto} S^{'}
	    \\
	      y\notin n(\gamma)
	  }{
	    (\nu y) S \stackrel{\gamma}{\longmapsto} (\nu y) S^{'}
	  }$
	&
	  $\inferrule* [left=\bf{OpnSeq}]{
	      P \xrightarrow{\sigma}\; P^{'}
	    \\ 
	      \exists \overline{x}z\in \sigma:\; x\neq z
	  }{
	      (\nu z)P \xrightarrow{opn(\sigma,z)}\; P^{'}
	  }$
      \\\\\\
	  $\inferrule* [left=\bf{Par1L}]{
	      S \stackrel{\gamma}{\longmapsto} S^{'}
% 	    \\ 
% 	      bn(\gamma)\cap fn(Q)=\emptyset
	  }{
	      S|Q \stackrel{\gamma}{\longmapsto} S^{'}|Q
	  }$
	&
	  $\inferrule* [left=\bf{Par1R}]{
	      S \stackrel{\gamma}{\longmapsto} S^{'}
% 	    \\ 
% 	      bn(\gamma)\cap fn(Q)=\emptyset
	  }{
	      Q|S \stackrel{\gamma}{\longmapsto} Q|S^{'}
	  }$
      \\\\\\
	  $\inferrule* [left=\bf{Par2L}]{
	     P \stackrel{\gamma}{\longmapsto} L
% 	    \\ 
% 	      bn(\gamma)\cap fn(Q)=\emptyset
	  }{
	      P|Q \stackrel{\gamma}{\longmapsto} L|*Q
	  }$
	&
	  $\inferrule* [left=\bf{Par2R}]{
	     P \stackrel{\gamma}{\longmapsto} L
% 	    \\ 
% 	      bn(\gamma)\cap fn(Q)=\emptyset
	  }{
	      Q|P \stackrel{\gamma}{\longmapsto} *Q|L
	  }$
      \\\\
	  $\inferrule* [left=\bf{Par3L}]{
	      L_{1} \stackrel{\gamma}{\longmapsto} L_{1}^{'}
% 	    \\ 
% 	      bn(\gamma)\cap fn(L_{2})=\emptyset
	  }{
	      L_{1}|L_{2} \stackrel{\gamma}{\longmapsto} L_{1}^{'}|L_{2}
	  }$
	&
	  $\inferrule* [left=\bf{Par3R}]{
	      L_{2} \stackrel{\gamma}{\longmapsto} L_{2}^{'}
% 	    \\ 
% 	      bn(\gamma)\cap fn(L_{2})=\emptyset
	  }{
	      L_{1}|L_{2} \stackrel{\gamma}{\longmapsto} L_{1}|L_{2}^{'}
	  }$
      \\\\\\
	&
	  $\inferrule* [left=\bf{Cong}]{
	      P\equiv P^{'}
	    \\
	      P^{'} \stackrel{\gamma}{\longmapsto} S
	  }{
	      P \stackrel{\gamma}{\longmapsto} S
	  }$
      \\\\\hline
    \end{tabular}
    \caption{Low multi $\pi$ early semantic with structural congruence}
    \label{lowleveltransitionrelation}
  \end{table}
\end{definition}

\begin{lemma}\label{lemmacom3}
  :\begin{itemize}
    \item
      It cannot happen that there exist an unmarked process $P$, a marked process $L$ and an action $\overline{x}y$ such that: $P\stackrel{\overline{x}y}{\longmapsto}L$. 
    \item
      Also it cannot be the case that there exist two unmarked processes $L_{1}, L_{2}$ and an action $\overline{x}y$ such that: $L_{1}\stackrel{\overline{x}y}{\longmapsto}L_{2}$
  \end{itemize}
  \begin{proof}
    DA FARE
  \end{proof}
\end{lemma}
