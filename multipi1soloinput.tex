
\section{Syntax}

As we did whit $\pi$ calculus, we suppose that we have a countable set of names $\mathbb{N}$, ranged over by lower case letters $a,b, \cdots, z$. This names are used for communication channels and values. Furthermore we have a set of identifiers, ranged over by $A$. We represent the agents or processes by upper case letters $P,Q, \cdots $. A multi $\pi$ process, in addiction to the same actions of a $\pi$ process, can perform also a strong prefix input:
\begin{center}
  $\pi$ ::= $\overline{x}y$ | $x(z)$ | $\underline{x(y)}$ | $\tau$ 
\end{center}
The process are defined, just as original $\pi$ calculus, by the following grammar:
\begin{center}
  \begin{tabular}{l}
    $P,Q$ ::= $0$ | $\pi.P$ | $P|Q$ | $P+Q$ | $(\nu x) P$ | $A(y_{1}, \cdots, y_{n})$
  \end{tabular}
\end{center}
and they have the same intuitive meaning as for the $\pi$ calculus. The strong prefix input allows a process to make an atomic sequence of actions, so that more than one process can synchronize on this sequence. For the moment we allow the strong prefix to be on input names only. Also one can use the strong prefix only as an action prefixing for processes that can make at least a further action. Since the strong prefix can be on input names only, the only synchronization possible is between a process that executes a sequence of $n$ actions(only the last action can be an output) with $n\geq 1$ and $n$ other processes each executing one single action(at least $n-1$ process execute an output and at most one executes an input).

Multi $\pi$ calculus is a conservative extension of the $\pi$ calculus in the sense that: any $\pi$ calculus process $p$ is also a multi $\pi$ calculus process and the semantic of $p$ according to the SOS rules of $\pi$ calculus is the same as the semantic of $p$ according to the SOS rules of multi $\pi$ calculus. 
We have to extend the following definition to deal with the strong prefix:
\begin{center}
  \begin{tabular}{ll}
	$B(\underline{x(y)}.Q, I)\; =\; \{y,\overline{y}\}\cup B(Q, I)$
      &
	$F(\underline{x(y)}.Q, I)\; =\; \{x,\overline{x}\}\cup (F(Q, I)-\{y,\overline{y}\})$
    \\
  \end{tabular}
\end{center}


In this setting two process cannot synchronize on a sequence of actions with length greater than one so we cannot have transactional synchronization but we can have multi-party synchronization.


\section{Operational semantic}

\subsection{Early operational semantic with structural congruence}

The semantic of a multi $\pi$ process is labeled transition system such that
\begin{itemize}
  \item 
    the nodes are multi $\pi$ calculus process. The set of node is $\mathbb{P}_{m}$
  \item
    the actions are multi $\pi$ calculus actions. The set of actions is $\mathbb{A}_{m}$, we use $\alpha, \alpha_{1}, \alpha_{2},\cdots $ to range over the set of actions, we use $\sigma, \sigma_{1}, \sigma_{2}, \cdots $ to range over the set $\mathbb{A}_{m}^{+} \cup \{\tau\}$.
  \item
    the transition relations is $\rightarrow\subseteq \mathbb{P}_{m}\times (\mathbb{A}_{m}^{+} \cup \{\tau\})\times \mathbb{P}_{m}$
\end{itemize}

In this case, a label can be a sequence of prefixes, whether in the original $\pi$ calculus a label can be only a prefix. We use the symbol $\cdot$ to denote the concatenation operator.

\begin{definition}\index{transition relation! multipi! input only! early! with structural congruence}
  The \emph{early transition relation with structural congruence} is the smallest relation induced by the rules in table \ref{multipisoloinputearlywith}.
  \begin{table}
    \begin{tabular}{ll}
	  \hline\\
	  $\inferrule* [left=\bf{Out}]{
	  }{
	    \overline{x}y.P \;\xrightarrow{\overline{x}y} P
	  }$
	&
	  $\inferrule* [left=\bf{EInp}]{
	  }{
	    x(y).P \;\xrightarrow{xz} P\{z/y\}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Tau}]{
	  }{
	    \tau.P \;\xrightarrow{\tau} P
	  }$
	&
	  $\inferrule* [left=\bf{SInp}]{
	      P\{y/z\} \xrightarrow{\sigma} P^{'}
	    \\
	      \sigma\neq \tau
% 	    \\
% 	      y\notin fn((\nu z) P)
	  }{
	    \underline{x(z)}.P \xrightarrow{xy \cdot \sigma} P^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Sum}]{
	    P \;\xrightarrow{\sigma} P^{'}
	  }{
	    P+Q \;\xrightarrow{\sigma} P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{Str}]{
	      P\equiv P^{'}
	    \\
	      P^{'}\; \xrightarrow{\alpha}\; Q^{'}
	    \\
	      Q\equiv Q^{'}
	  }{
	      P\; \xrightarrow{\alpha}\; Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{Com}]{
	      P \xrightarrow{\overline{x}y} P^{'}
	    \\
	      Q \xrightarrow{xy} Q^{'}
	  }{
	    P|Q \xrightarrow{\tau} P^{'}|Q^{'}
	  }$
	&
	  $\inferrule* [left=\bf{ComSeq}]{
	      P \xrightarrow{xy\cdot \sigma} P^{'}
	    \\
	      Q \xrightarrow{\overline{x}y} Q^{'}
	  }{
	    P|Q \xrightarrow{\sigma} P^{'}|Q^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Res}]{
	      P\; \xrightarrow{\sigma}\; P^{'}
	    \\
	      z\notin n(\alpha)
	  }{
	    (\nu z) P \;\xrightarrow{\sigma} (\nu z) P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{SInpTau}]{
	      P\{y/z\}\; \xrightarrow{\tau}\; P^{'}
	  }{
	    \underline{x(z)}.P \;\xrightarrow{xy} P^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Par}]{
	      P \;\xrightarrow{\sigma}\; P^{'}
	    \\ 
	      bn(\sigma)\cap fn(Q)=\emptyset
	  }{
	      P|Q \;\xrightarrow{\sigma} P^{'}|Q
	  }$
	&
	  $\inferrule* [left=\bf{Opn}]{
	      P \xrightarrow{\overline{x}z}\; P^{'}
	    \\ 
	      z\neq x
	  }{
	      (\nu z)P \xrightarrow{\overline{x}(z)}\; P^{'}
	  }$
      \\\hline
    \end{tabular}
    \caption{Multi $\pi$ early semantic with structural congruence}
    \label{multipisoloinputearlywith}
  \end{table}
\end{definition}



\begin{example}[Multi-party synchronization]
  We show an example of a derivation of three processes that synchronize.
  \begin{center}
  $
      \inferrule* [left=\bf{EComSng}]{
	\underline{x(a)}.x(b).P|\overline{x}y.Q)
	  \xrightarrow{xz}
	    P\{y/a\}\{z/b\}|Q
	\\
	  \inferrule* [left=\bf{Out}]{
	  }{
	    \overline{x}z.R	
	      \xrightarrow{\overline{x}z} 
		R
	  }
      }{
	(\underline{x(a)}.x(b).P|\overline{x}y.Q)|\overline{x}z.R
	  \xrightarrow{\tau}
	    (P\{y/a\}\{z/b\}|Q)|R
      }
  $
  \end{center}
  
  \begin{center}
  $\inferrule* [left=\bf{EComSeq}]{
      \inferrule* [left=\bf{SInp}]{
	\inferrule* [left=\bf{EInp}]{
	}{
	  (x(b).P)\{y/a\} \xrightarrow{xz} P\{y/a\}\{z/b\}
	}
      }{
	\underline{x(a)}.(x(b).P) 
	  \xrightarrow{xy \cdot xz} 
	    P\{y/a\}\{z/b\}
      }
    \\
      \inferrule* [left=\bf{Out}]{
      }{
	\overline{x}y.Q\; \;\xrightarrow{\overline{x}y}\; Q
      }
  }{
	\underline{x(a)}.x(b).P|\overline{x}y.Q)
	  \xrightarrow{xz}
	    P\{y/a\}\{z/b\}|Q
  }$
  \end{center}

\end{example}





% \begin{example}
%   We show an example of three processes that synchronize. In particular we prove that
%   \begin{description}
%     \item[Res]
%       $(\nu x)((\underline{x(y)}.x(y).0|\overline{x}y.0)|\overline{x}y.0)\; 
% 	\;\xrightarrow{\tau}\; 
% 	  (\nu x)((0|0)|0)$
%       \begin{description}
% 	\item
% 	  $x\notin n(\tau)$
% 	\item[Com]
% 	      $((\underline{x(y)}.x(y).0|\overline{x}y.0)|\overline{x}y.0)\; 
% 		\;\xrightarrow{\tau}\; 
% 		  ((0|0)|0)$
% 	      \begin{description}
% 	       \item[Com]
% 		  $\underline{x(y)}.x(y).0|\overline{x}y.0\; 
% 		    \;\xrightarrow{xy}\; 
% 		      0|0$
% 		  \begin{description}
% 		    \item[Com2L]
% 		      $Sync(xy\cdot xy,xy,xy)$
% 		    \item[Einp]
% 		      $\overline{x}y.0\; \;\xrightarrow{xy}\; 0$
% 		    \item[SOut]
% 		      $\underline{x(y)}.x(y).0\; 	
% 			\;\xrightarrow{xy\cdot xy}\; 
% 			  0$
% 		    \begin{description}
% 		      \item
% 			$x(y)\neq \tau$
% 		      \item[Out]
% 			$x(y).0\; 
% 			\;\xrightarrow{xy}\; 
% 			  0$
% 		    \end{description}
% 		  \end{description}
% 		\item[Out]
% 		  $\overline{x}y.0\; \;\xrightarrow{xy}\; 0$
% 		\item[Com1]
% 		  $Sync(xy,xy,\tau)$   
% 	      \end{description}
%       \end{description}
%   \end{description}
% \end{example}
% 
% 
% \begin{example}
%   We want to prove that 
%   \[
%     (\underline{a(x)}.c(x).0|\overline{b}x.0)|(\overline{a}x.0|\underline{b(x)}.\overline{c}x.0)\;
%       \;\xrightarrow{\tau}\; 
% 	(0|0)|(0|0)
%   \]:
%   \begin{description}
%     \item[Str]
%       $(\underline{a(x)}.c(x).0|\overline{b}x.0)|(\overline{a}x.0|\underline{b(x)}.\overline{c}x.0)\;
% 	\;\xrightarrow{\tau}\; 
% 	  (0|0)|(0|0)$
%       \begin{description}
% 	\item[Com] 
% 	  $(\underline{a(x)}.c(x).0|\overline{a}x.0)|(\overline{b}x.0|\underline{b(x)}.\overline{c}x.0)\;
% 	    \;\xrightarrow{\tau}\;
% 	      (0|0)|(0|0)$
% 	  \begin{description}
% 	    \item[Com1R]
% 	      $Sync(cx, \overline{c}x, \tau)$
% 	    \item[Com]
% 	      $\overline{b}x.0|\underline{b(x)}.\overline{c}x.0\;
% 		\;\xrightarrow{\overline{c}x}\;
% 		  0|0$
% 	      \begin{description}
% 		\item[EInp]
% 		  $\overline{b}x.0
% 		    \;\xrightarrow{\overline{b}x}\;
% 		      0$
% 		\item[SOut]
% 		  $\underline{b(x)}.\overline{c}x.0\;
% 		    \;\xrightarrow{bx\cdot \overline{c}x}\;
% 		      0$
% 		  \begin{description}
% 		    \item[Out]
% 		      $\overline{c}x.0\;
% 			\;\xrightarrow{\overline{c}x}\;
% 			  0$
% 		  \end{description}
% 		\item[Com2R]
% 		  $Sync(\overline{b}x,bx\cdot \overline{c}x,\overline{c}x)$
% 	      \end{description}
% 	    \item[Com]
% 	      $\underline{a(x)}.c(x).0|\overline{a}x.0\;
% 		\;\xrightarrow{cx}\;
% 		  0|0$
% 	      \begin{description}
% 		\item[SOut]
% 		  $\underline{a(x)}.c(x).0\;
% 		    \;\xrightarrow{ax\cdot cx}\;
% 		      0$
% 		  \begin{description}
% 		    \item[Inp]
% 		      $c(x).0\;
% 			\;\xrightarrow{cx}\;
% 			  0$
% 		  \end{description}
% 		\item[Inp]
% 		  $\overline{a}x.0\;
% 		    \;\xrightarrow{ax}\;
% 		      0$
% 		\item[Com2L]
% 		  $Sync(ax\cdot cx, \overline{a}x, cx)$
% 	      \end{description}
% 	  \end{description}
% 	\item[]
% 	  $(\underline{a(x)}.c(x).0|\overline{b}x.0)|(\overline{a}x.0|\underline{b(x)}.\overline{c}x.0)\;
% 	    \equiv\;
% 	      (\underline{a(x)}.c(x).0|\overline{a}x.0)|(\overline{b}x.0|\underline{b(x)}.\overline{c}x.0)$
%       \end{description}
%   \end{description}
% \end{example}
% 
% 
% \begin{example}
%   The \emph{dining philosophers} problem, originally proposed by Dijkstra in \cite{djkstra}, is defined in the following way: Five silent philosophers sit at a round table. There is one fork between each pair of adjacent philosophers. Each philosopher must alternately think and eat. However, a philosopher can only eat while holding both the fork to the left and the fork to the right. Each philosopher can pick up an adjacent fork, when available, and put it down, when holding it. The problem is to design an algorithm such that no philosopher will starve, i.e. can forever continue to alternate between eating and thinking. We present one solution which uses only two forks and two philosophers:
%   \begin{itemize}
%     \item
%       we define two constants for the forks:
%       \begin{center}
% 	\begin{tabular}{ll}
% 	    $fork_{1}\; \stackrel{def}{=}\; \overline{up_{1}}x.\overline{dn_{1}}x.fork_{1}$
% 	  &
% 	    $fork_{0}\; \stackrel{def}{=}\; \overline{up_{0}}x.\overline{dn_{0}}x.fork_{0}$
% 	\end{tabular}
%       \end{center}
%       the input name $x$ is not important and can be anything else.
%     \item
%       we define two constants for the philosophers:
%       \begin{center}
% 	\begin{tabular}{l}
% 	    $phil_{1}\; \stackrel{def}{=}\; 
% 	      think(x).phil_{1}
% 	    +
% 	      \underline{up_{1}(x)}.up_{0}(x).eat(x).\underline{dn_{1}(x)}.dn_{0}(x).phil_{1}$
% 	  \\
% 	    $phil_{0}\; \stackrel{def}{=}\; 
% 	      think(x).phil_{0}
% 	    +
% 	      \underline{up_{0}(x)}.up_{1}(x).eat(x).\underline{dn_{0}(x)}.dn_{1}(x).phil_{0}$
% 	\end{tabular}
%       \end{center}
%       also in this case the name $x$ is not relevant.
%     \item
%       the following definition describe the whole system with philosophers and forks:
%       \begin{center}
% 	$DP\; \stackrel{def}{=}\; (\nu \{up_{0}, up_{1}, down_{0}, down_{1}\})(phil_{0}|phil_{1}|fork_{0}|fork_{1})$
%       \end{center}
%       where with $(\nu \{up_{0}, up_{1}, down_{0}, down_{1}\})$ we mean $(\nu\; up_{0}) (\nu\; up_{1}) (\nu\; down_{0}) (\nu\; down_{1})$
%     \item
%       the operational semantic of $DP$ is the following lts:
%       \begin{center}
% 	\begin{tikzpicture}[%
% 	    ->,
% 	    >=stealth,
% 	    shorten >=1pt,
% 	    node distance=2.8cm,
% 	    %on grid,
% 	    auto,
% 	    state/.append style={minimum size=2em},
% 	    thick
% 	  ]
% 
% 
%   %\tikzstyle{every state}=[fill=red,draw=none,text=white]
% 
% 
% 	  \node[state] (A) {$P_{1}eaten$};
% 	  \node[state] (B) [below right of=A] {$P_{1}F_{0,1}$};
% 	  \node[state] (DP)[above right of=B] {$DP$};
% 	  \node[state] (C) [below right of=DP] {$P_{0}F_{0,1}$};
% 	  \node[state] (D) [above right of=C] {$P_{0}eaten$};
%   
% 	  \path[->] 
% 	      
%               (DP)       edge [loop above] node {$think\;x$} (DP)
% 			 edge              node {$\tau$} (C)
% 			 edge              node {$\tau$} (B)
% 	      (A)        edge [loop above] node {$think\;x$} (A)
% 			 edge              node {$\tau$} (DP)
% 	      (B)        edge [loop below] node {$think\;x$} (B)
% 			 edge   	   node {$eat\;x$} (A)
% 	      (C)        edge [loop below] node {$think\;x$} (C)
% 			 edge              node {$eat\;x$} (D)
% 	      (D)        edge [loop above] node {$think\;x$} (D)
% 			 edge              node {$\tau$} (DP);
%          
%       \end{tikzpicture}
%     \end{center}
%   \end{itemize}
%   Now we need to prove every transition in the semantic of $DP$. Let $L=\{up_{0}, up_{1}, down_{0}, down_{1}\}$ we start with $DP\xrightarrow{\tau}DP$:
% 
% 
% 
% \end{example}
% 
% \begin{example}
%   We want to show now an example of synchronization between four processes:
%   \begin{description}
%     \item[Res]
%       $(\nu\; a)((((\underline{a(x)}.\underline{a(x)}.a(x).0| \overline{a}x.0)| \overline{a}x.0)| \overline{a}x.0)\;\;
% 	\xrightarrow{\tau}\;
% 	  (\nu\; a)(((0|0)|0)|0))$
%       \begin{description}
% 	\item
% 	  $a\notin n(\tau)$
% 	\item[Com]
% 	  $((\underline{a(x)}.\underline{a(x)}.a(x).0| \overline{a}x.0)| \overline{a}x.0)| \overline{a}x.0\;\;
% 	    \xrightarrow{\tau}\;
% 	      ((0|0)|0)|0$
% 	  \begin{description}
% 	    \item[Com]
% 	      $(\underline{a(x)}.\underline{a(x)}.a(x).0| \overline{a}x.0)| \overline{a}x.0\;\;
% 		\xrightarrow{ax}\;
% 		   (0|0)|0$
% 	      \begin{description}
% 		\item[Com]
% 		  $\underline{a(x)}.\underline{a(x)}.a(x).0| \overline{a}x.0\;\;
% 		    \xrightarrow{ax\cdot ax}\;
% 		      0|0$
% 		  \begin{description}
% 		    \item[SOut]
% 		      $\underline{a(x)}.\underline{a(x)}.a(x).0\;\;
% 			  \xrightarrow{ax\cdot ax\cdot ax}\;
% 			    0$
% 		      \begin{description}
% 			\item[SOut]
% 			  $\underline{a(x)}.a(x).0\;\;
% 			    \xrightarrow{ax\cdot ax}\;
% 			      0$\newline
%  			  %\begin{description}
%  			  %   \item[SOut]
%  				$\;\;\;\; {\bf SOut}\; \underline{a(x)}.a(x).0\;\;
% 				  \xrightarrow{ax\cdot ax}\;
% 				    0$\newline
% 	     			%\begin{description}
% 				%   \item[SOut]
% 				      .\hspace{4 mm}${\bf Out}\; a(x).0\;\;
% 					\xrightarrow{ax}\;
% 					   0$
% 				%\end{description}
%  			  %\end{description}
% 		      \end{description}
% 		    \item[Inp]
% 		      $\overline{a}x.0\;\;\xrightarrow{\overline{a}x}\;0$
% 		    \item[Com2L]
% 		      $Sync(
% 			ax \cdot ax \cdot ax,
% 			\overline{a}x,
% 			ax \cdot ax
% 		      )$
% 		  \end{description}
% 		\item[Inp]
% 		  $\overline{a}x.0\;\;\xrightarrow{\overline{a}x}\;0$	 
% 		\item[Com2L]
% 		  $Sync(ax\cdot ax,\overline{a}x,ax)$
% 	      \end{description}
% 	    \item[Inp]
% 	      $\overline{a}x.0\;\;\xrightarrow{\overline{a}x}\;0$	      
% 	    \item[Com1L]
% 	      $Sync(ax,\overline{a}x,\tau)$
% 	  \end{description}
%     \end{description}
%   \end{description}
% 
% \end{example}
% 
% 
% 

\subsection{Late operational semantic with structural congruence}
% % Definisci le regole late per Multi-pi. In questo caso credo sia indispensabile la restrizione sintattica che ti suggerivo(solo input nello strong prefixing e sincronizzazione solo con la prima), mentre mi pare che nel caso early dovrebbe funzionare anche il caso generale con Sync. 

\begin{definition}\index{transition relation! multipi! input only! late! with structural congruence}
  The \emph{late transition relation with structural congruence} is the smallest relation induced by the rules in table \ref{multipisoloinputlateywith}.
  \begin{table}
    \begin{tabular}{ll}
	\hline\\
     	  $\inferrule* [left=\bf{Pref}]{
	    \alpha\; not\; a\; strong\; prefix
	  }{
	    \alpha.P \;\xrightarrow{\alpha} P
	  }$
	&
	  $\inferrule* [left=\bf{LComSeq}]{
	      P \;\xrightarrow{x(y)\cdot \sigma} P^{'}
	    \\
	      Q\;\xrightarrow{\overline{x}z} Q^{'}
	    \\
	      z\notin fn(\sigma)\cup fn(P)
	  }{
	    P|Q \;\xrightarrow{\sigma\{z/y\}} P^{'}\{z/y\}|Q^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{SInp}]{
	      P\; \xrightarrow{\sigma}\; P^{'}
	    \\
	      \sigma\neq \tau
	  }{
	    \underline{x(y)}.P \;\xrightarrow{x(y) \cdot \sigma} P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{LComSng}]{
	      P \;\xrightarrow{x(y)} P^{'}
	    \\
	      Q\;\xrightarrow{\overline{x}z} Q^{'}
	    \\
	      z\notin fn(P)
	  }{
	    P|Q \;\xrightarrow{\tau} P^{'}\{z/y\}|Q^{'}
	  }$

      \\\\
	  $\inferrule* [left=\bf{Sum}]{
	    P\; \xrightarrow{\sigma}\; P^{'}
	  }{
	    P+Q \;\xrightarrow{\sigma} P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{Str}]{
	      P\equiv P^{'}
	    \\
	      P^{'}\; \;\xrightarrow{\alpha}\; Q^{'}
	    \\
	      Q\equiv Q^{'}
	  }{
	      P\; \;\xrightarrow{\alpha}\; Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{Res}]{
	      P\; \xrightarrow{\sigma}\; P^{'}
	    \\
	      z\notin n(\alpha)
	  }{
	    (\nu z) P \;\xrightarrow{\sigma} (\nu z) P^{'}
	  }$
	&
	  $\inferrule* [left=\bf{Par}]{
	      P\; \xrightarrow{\sigma}\; P^{'}
	    \\
	      bn(\sigma)\cup fn(Q)=\emptyset
	  }{
	    P|Q \;\xrightarrow{\sigma} P^{'}|Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{Opn}]{
	      P \xrightarrow{\overline{x}z}\; P^{'}
	    \\ 
	      z\neq x
	  }{
	      (\nu z)P \xrightarrow{\overline{x}(z)}\; P^{'}
	  }$
	&
      \\\hline
    \end{tabular}
    \caption{Multi $\pi$ late semantic with structural congruence}
    \label{multipisoloinputlateywith}
  \end{table}
\end{definition}

\begin{example}[Multi-party synchronization]
  We show an example of a derivation of three processes that synchronize with the late semantic. The three processes are $\underline{x(a)}.x(b).P$, $\overline{x}y.Q$ and $\overline{x}z.R$. We assume that:
  \begin{center}
      $a\notin fn(x(b))\cup fn (\underline{x(a)}.x(b).P)$
  \end{center}
  and
  \begin{center}
      $b\notin fn(\underline{x(a)}.x(b).P|\overline{x}y.Q)$
  \end{center}

  \begin{center}
  $
      \inferrule* [left=\bf{LComSng}]{
	\underline{x(a)}.x(b).P|\overline{x}y.Q
	  \xrightarrow{x(b)}
	    P\{y/a\}|Q
	\\
	  \inferrule* [left=\bf{Pref}]{
	  }{
	    \overline{x}z.R	
	      \xrightarrow{\overline{x}z} 
		R
	  }
      }{
	(\underline{x(a)}.x(b).P|\overline{x}y.Q)|\overline{x}z.R
	  \xrightarrow{\tau}
	    (P\{y/a\}|Q)\{z/b\}|R
      }
  $
  \end{center}
  
  \begin{center}
  $\inferrule* [left=\bf{LComSeq}]{
      \inferrule* [left=\bf{SInp}]{
	\inferrule* [left=\bf{Pref}]{
	}{
	  x(b).P \xrightarrow{x(b)} P
	}
      }{
	\underline{x(a)}.x(b).P
	  \xrightarrow{x(a) \cdot x(b)} 
	    P
      }
    \\
      \inferrule* [left=\bf{Out}]{
      }{
	\overline{x}y.Q\; \;\xrightarrow{\overline{x}y}\; Q
      }
  }{
	\underline{x(a)}.x(b).P|\overline{x}y.Q)
	  \xrightarrow{x(b)}
	    P\{y/a\}|Q
  }$
  \end{center}

\end{example}



\subsection{Low level semantic}
This section contains the definition of an alternative semantic for multi $\pi$. First we define a low level version of the multi $\pi$ calculus(here with strong prefixing on input only), we call this language low multi $\pi$. The low multi $\pi$ is the multi $\pi$ enriched with a marked or intermediate process $*P$:
\begin{center}
   \begin{tabular}{l}
     $P,Q$ ::= $0$ | $\pi.P$ | $P|Q$ | $P+Q$ | $(\nu x) P$ | $A(x_{1}, \cdots, x_{n})$ | $*P$
   \\\\
     $\pi$ ::= $\overline{x}y$ | $x(z)$ | $\underline{x(y)}$ | $\tau$ 
   \end{tabular}
\end{center}
\begin{definition}
  The low level transition relation is the smallest relation induced by the rules in table \ref{lowleveltransitionrelation} in which $P$ stands for a process without mark, $L$ stands for a process with mark and $S$ can stand for both. 
  \begin{table}
    \begin{tabular}{ll}
	  \hline\\
	  $\inferrule* [left=\bf{Out}]{
	  }{
	    \overline{x}y.P \stackrel{\overline{x}y}{\longmapsto} P
	  }$
	&
	  $\inferrule* [left=\bf{EInp}]{
	    y\notin fn(P)-\{z\}
	  }{
	    x(z).P \stackrel{xy}{\longmapsto} P\{y/z\}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Tau}]{
	  }{
	    \tau.P \stackrel{\tau}{\longmapsto} P
	  }$
	&
	  $\inferrule* [left=\bf{SInp}]{
 	      y\notin fn(P)-\{z\}
	  }{
	    \underline{x(z)}.P \stackrel{xy}{\longmapsto} * P\{y/z\}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Sum}]{
	    P \stackrel{\gamma}{\longmapsto} S
	  }{
	    P+Q \stackrel{\gamma}{\longmapsto} S
	  }$
	&
	  $\inferrule* [left=\bf{Str}]{
	      P\equiv P^{'}
	    \\
	      P^{'} \stackrel{\gamma}{\longmapsto} Q^{'}
	  }{
	      P \stackrel{\gamma}{\longmapsto} Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{Com1}]{
	      P \stackrel{\overline{x}y}{\longmapsto} P^{'}
	    \\
	      Q \stackrel{xy}{\longmapsto} Q^{'}
	  }{
	    P|Q \stackrel{\tau}{\longmapsto} P^{'}|Q^{'}
	  }$
	&
	  $\inferrule* [left=\bf{Com2}]{
	      L_{1} \stackrel{\overline{x}y}{\longmapsto} L_{1}^{'}
	    \\
	      L_{2} \stackrel{xy}{\longmapsto} S^{'}
	  }{
	    L_{1}|L_{2} \stackrel{\epsilon}{\longmapsto} L_{1}^{'}|S^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Com3}]{
	      P \stackrel{\overline{x}y}{\longmapsto} L
	    \\
	      Q \stackrel{xy}{\longmapsto} S
	  }{
	    P|Q \stackrel{\epsilon}{\longmapsto} L|S
	  }$
	&
	  $\inferrule* [left=\bf{Com4}]{
	      L_{1} \stackrel{\overline{x}y}{\longmapsto} P
	    \\
	      L_{2} \stackrel{xy}{\longmapsto} Q
	  }{
	    L_{1}|L_{2} \stackrel{\tau}{\longmapsto} P|Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{Res}]{
	      S \stackrel{\gamma}{\longmapsto} S^{'}
	    \\
	      y\notin n(\gamma)
	  }{
	    (\nu y) S \stackrel{\gamma}{\longmapsto} (\nu y) S^{'}
	  }$
	&
	  $\inferrule* [left=\bf{Opn}]{
	      S \stackrel{\overline{x}y}{\longmapsto} S^{'}
	    \\ 
	      y\neq x
	    \\
	      w\notin fn(S^{'})
	  }{
	      (\nu y)S \stackrel{\overline{x}(w)}{\longmapsto} S^{'}\{w/y\}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Par1}]{
	      S \stackrel{\gamma}{\longmapsto} S^{'}
	    \\ 
	      bn(\gamma)\cap fn(Q)=\emptyset
	  }{
	      S|Q \stackrel{\gamma}{\longmapsto} S^{'}|Q
	  }$
	&
	  $\inferrule* [left=\bf{Par2}]{
	     P \stackrel{\gamma}{\longmapsto} L
	    \\ 
	      bn(\gamma)\cap fn(Q)=\emptyset
	  }{
	      P|Q \stackrel{\gamma}{\longmapsto} L|*Q
	  }$
      \\\\
	  $\inferrule* [left=\bf{Par3}]{
	      L_{1} \stackrel{\gamma}{\longmapsto} L_{1}^{'}
	    \\ 
	      bn(\gamma)\cap fn(L_{2})=\emptyset
	  }{
	      L_{1}|L_{2} \stackrel{\gamma}{\longmapsto} L_{1}^{'}|L_{2}
	  }$
	&
	  $\inferrule* [left=\bf{Cong1}]{
	      P\equiv P^{'}
	    \\
	      P^{'} \stackrel{\gamma}{\longmapsto} Q^{'}
	  }{
	      P \stackrel{\gamma}{\longmapsto} Q^{'}
	  }$
      \\\\
	  $\inferrule* [left=\bf{Cong2}]{
	      P\equiv Q
	    \\
	      Q \stackrel{\gamma}{\longmapsto} L
	  }{
	      P \stackrel{\gamma}{\longmapsto} L
	  }$
	&
	  $\inferrule* [left=\bf{Cong3}]{
	      L \stackrel{\gamma}{\longmapsto} Q
	    \\
	      Q\equiv P
	  }{
	      L \stackrel{\gamma}{\longmapsto} P
	  }$
      \\\\
	  $\inferrule* [left=\bf{Star}]{
	      S \stackrel{\gamma}{\longmapsto} S^{'}
	  }{
	      *S \stackrel{\gamma}{\longmapsto} S^{'}
	  }$
	&
      \\\\\hline
    \end{tabular}
    \caption{Low multi $\pi$ early semantic with structural congruence}
    \label{lowleveltransitionrelation}
  \end{table}
\end{definition}

  
\begin{definition}
  Let $P, Q$ be unmarked processes and $L_{1}, \cdots, L_{k-1}$ marked processes. We define the derivation relation $\rightarrow_{s}$ in the following way:
  \begin{center}
    $\inferrule* [left=\bf{Low}]{
	P \stackrel{\gamma_{1}}{\longmapsto} L_{1} \stackrel{\gamma_{2}}{\longmapsto} L_{2} \cdots L_{k-1} \stackrel{\gamma_{k}}{\longmapsto} Q
      \\
	k\geq 1
    }{
      P \xrightarrow{\gamma_{1} \cdots \gamma_{k}}_{s}  Q
    }$
  \end{center}
\end{definition}


\begin{proposition}
  Let $\rightarrow$ be the relation defined in table \ref{multipisoloinputearlywith} and let $P$ be a multi $\pi$ process. Then 
  \begin{center}
    $P\xrightarrow{\sigma} Q \Leftrightarrow P\xrightarrow{\sigma}_{s} Q$
  \end{center}
  \begin{proof}
    The proof of $\Rightarrow$ direction is by induction on the depth of the derivation tree of $P\xrightarrow{\sigma} Q$:
    \begin{description}
      \item[base case]
	
      \item[inductive case]
	
    \end{description}

    
    The proof of $\Leftarrow$ direction is by induction on the length of the sequence of transitions used to derive $P\xrightarrow{\sigma}_{s} Q$ and on the depth of the proof tree of the first transition in such a sequence:
  \end{proof}
\end{proposition}





