

ho pensato che dovrebbe essere possibile risolvere il problema dei sigarette smokers anche nel calcolo ristretto in cui lo strong prefixing si usa per soli input (o soli output). Non intendo dire che sia possibile implementare la soluzione con multiway synchronization (questo e' gia' scritto nel paper che le ho dato), ma proprio la versione con transactional synchronization (che nel paper che le ho dato usa prefissi forti misti). Infatti, poiche' una transazione puo' essere una sequenza di input *che termina con un output*, posso usare questo per concatenare varie sequenze di sincronizzazione: l'output terminale del primo si sincronizza con un input iniziale dell'altro, che poi terminera' con un output che si sincronizza con un input iniziale del primo ... L'unico aspetto critico e' che serve avere un'azione privata per ogni agente che voglia sincronizzarsi col gestore del servizio in modo da garantire il corretto linking delle varie sottosequenze.






Caro Viscomi,

in realta' la "soluzione" che suggerisco sotto funziona solo sotto ipotesi
che il nome b non sia un bound name di A, altrimenti potrebbe
erroneamente legare vecchie occorrenze di a, ora ridenominate in b.

Piu' in generale dovrebbe fare un mix della soluzione per CCS e di quella
sotto, ovvero generare una nuova costante al cui corpo applicare la
sostituzione, che avrebbe l'effetto di fare eventuali renaming dove
opportuno, e nello stesso tempo sostituire i parametri (come sotto).

Cordiali saluti,
R.G.

P.S.: ma di cosa ha discusso con Sangiorgi?

>>1. aveva detto che la definizione di sostituzione non andava bene nel
>>caso delle costanti pero' non ricordo piu' il perche' per caso la
> definizione
>>di sostituzione ha lo stesso problema di ricorsione infinita
>>che avevano la fn e la bn?
>
> Dunque, riflettendo un attimo sul fatto che le costanti hanno parametri e
> che questi parametri sono tutte le azioni libere del corpo, mi pare che la
> si possa semplificare molto rispetto a quella per CCS che tu usi. La nuova
> definizione potrebbe essere la seguente:
>
>       A(x_1, …, x_n){b/a} = A(x_1{b/a}, …, x_n{b/a})
>
> Nella regola attuale, che e’ ispirata al caso del CCS, invece, il problema
> della ricorsione infinita non si presenta se const(A) è finito; ovviamente
> se l’insieme delle costanti di un processo è infinito, allora è
> inevitabile la non terminazione della procedura di sostituzione. Ma il
> vantaggio del pi-calcolo è che tutte le azioni free sono messe come
> parametri, e quindi la sostituzione si applica solo ai parametri (molto
> piu’ semplice; non c’è bisogno di definirsi nuove costanti).









Caro Viscomi,

ripensandoci meglio, credo che il problema delle costanti possa essere
risolto piu’ elegantemente semplicemente modificando la definizione delle
costanti in modo che esse comprendano non solo i free names, ma anche i
bound names. Ovvero, la def di A e’:

A(x_1, …, x_n | y_1, …, y_m) = Q

dove fn(Q) \subseteq {x_1, …, x_n} e bn(Q) \subseteq {y_1, …, y_m}.
Ora la definizione di sostituzione risulta ovvia, e senza
bisogno di avere costanti addizionali:

A(x_1, …, a, …, x_n | y_1, …, y_m){b/a} =
    A(x_1, …, b, …, x_n | y_1, …, y_m)

se b non compare tra i bound names, mentre

A(x_1, …, a, …, x_n | y_1, …, b, … , y_m){b/a} =
   A(x_1, …, b, …, x_n | y_1, …, c, …, y_m)

dove c e’ un nome nuovo.
Questo risolve anche il problema che lei aveva con
il Lemma 2.3.1. di pagina 15.

Saluti,
r.g.






Gentile prof. Roberto Gorrieri,

putroppo ho ancora dei dubbi, se scriviamo
A(x_1, …, a, …, x_n | y_1, …, y_m){b/a} =
    A(x_1, …, b, …, x_n | y_1, …, y_m)
non dobbiamo anche dire che
    A(x_1, …, b, …, x_n | y_1, …, y_m) =def Q\{b/a\}
?
altrimenti cosa significa di preciso  A(x_1, …, b, …, x_n | y_1, …, y_m)?

se la definizione
 A(x_1, …, b, …, x_n | y_1, …, y_m) =def Q\{b/a\}
e' valida ma da il problema della ricorsione infinita non possiamo aggiungere un parametro che ricorda l'insieme delle costanti modificate?

Non ricordo bene se mi aveva detto o scritto che voleva vedere il libro del prof. Davide Sangiorgi, in caso positivo posso lasciarle la mia copia oggi o domani in dipartimento. Comunque lui usa il bang per la ricorsione e quindi almeno in questo caso non ci aiuta.

Cordiali saluti,
Federico Viscomi.


Caro Viscomi:

> putroppo ho ancora dei dubbi, se scriviamo
> A(x_1, …, a, …, x_n | y_1, …, y_m){b/a} =
>     A(x_1, …, b, …, x_n | y_1, …, y_m)
> non dobbiamo anche dire che
>     A(x_1, …, b, …, x_n | y_1, …, y_m) =def Q\{b/a\}
> ?
> altrimenti cosa significa di preciso  A(x_1, …, b, …, x_n | y_1, …, y_m)?
>
> se la definizione
>  A(x_1, …, b, …, x_n | y_1, …, y_m) =def Q\{b/a\}
> e' valida ma da il problema della ricorsione infinita non possiamo
> aggiungere un parametro che ricorda l'insieme delle costanti modificate?

Dobbiamo partire dal fatto che esiste *UNA* definizione di
costante
    A(x_1, …, x_n | y_1, …, y_m) =def Q
dove tutte le x_i sono distinte e tutte le y_j sono distinte, tale che
fn(Q) \subseteq {x_1, ..., x_n}   e  bn(Q) \subseteq {y_1, ..., y_m}
Dobbiamo poi ricordare che per ogni istanziazione di x_1,..,x_n
e y_1,..,y_m abbiamo una specifica *incarnazione* della
costante (ma non una nuova definizione), grazie alla regola operazionale
della costante (Cns come la chiami tu) o all'assioma,
se si usa congruenza strutturale. Quindi la sostituzione di cui tu parli
la va a fare la regola operazionale della costante: non ho bisogno di una
nuova costante.


> Non ricordo bene se mi aveva detto o scritto che voleva vedere il libro
> del prof. Davide Sangiorgi, in caso positivo posso lasciarle la mia copia
> oggi o domani in dipartimento. Comunque lui usa il bang per la ricorsione
> e quindi almeno in questo caso non ci aiuta.


Si, potremmo vederci martedi' prossimo verso le 11:30. Ho anche altre cose
da dirle/suggerirle da fare durante le vacanze. Le consiglio da subito di
guardarsi come Sangiorgi tratta la barbed congruence, cosi' ne parliamo
...

Saluti,
r.g.


> Cordiali saluti,
> Federico Viscomi.